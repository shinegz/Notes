# 网络模型

## OSI模型

> **开放式系统互联模型**（英语：**O**pen **S**ystem **I**nterconnection Model，缩写：OSI；简称为**OSI模型**）是一种概念模型，由国际标准化组织提出，一个试图使各种计算机在世界范围内互连为网络的标准框架。

## TCP/IP模型

> TCP/IP 模型是 OSI 模型在Internet中的实现。

<img src=".\计算机网络学习笔记\TCP_IP模型.png" style="zoom:50%;" />

## 模型分层的原因

> 网络通信是一个非常复杂的过程，通过分层，每层只负责通信的一个方面。这样不同领域的开发人员（通信软件开发人员、路由器开发人员、通信介质开发人员等）只需实现通信系统的一部分，而不需要考虑所有通信细节。



## 模型分层的优劣

+ 优点
  + 层与层之间耦合度低，在层间接口不变的情况下，各层自身的改变不会影响到其他层
+ 缺点
  + 层与层之间的数据交互过程会带来一定的延时



# 应用层



# 传输层

> 网络层只把分组发送到目的主机，但真正通信的并不是主机而是**主机中的进程**。
>
> 传输层提供了**进程间的逻辑通信**，传输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来像是在两个传输层实体之间有一条端到端的逻辑通信信道。

## UDP和TCP的特点

+ 用户数据报协议 UDP（User Datagram Protocol）是**无连接**的，尽最大可能交互，没有拥塞控制，**面向报文**（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。

+ 传输控制协议 TCP（Transmission Control Protocol）是**面向连接**的，提供**可靠交付**，有**流量控制**，**拥塞控制**，提供全双工通信，**面向字节流**（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是**点对点**的（一对一）。



## UDP首部格式

<img src=".\计算机网络学习笔记\UDP首部.jpg" style="zoom:50%;" />

首部字段只有8个字节，包括源端口、目的端口、长度、校验和。12字节的伪首部是为了计算检验和临时添加的。



## TCP首部格式

<img src=".\计算机网络学习笔记\TCP首部.png" style="zoom:50%;" />

+ **序号**：用于对字节流进行编号，例如序号为301，表示第一个字节的编号为301，如果携带的数据长度为100字节，那么下一个报文段的序号应为401。
+ **确认号**：期望收到的下一个报文段的序号。例如B正确收到A发送来的一个报文段，序号为501，携带的数据长度为200字节，因此B期望下一个报文段的序号为701，B发送给A的确认号就为701。
+ **数据偏移**：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。
+ **确认ACK**：当ACK=1时确认号字段有效，否则无效。TCP规定，在连接建立后所有传送的报文段都必须把ACK置1。
+ **同步SYN**：在连接建立时用来同步序号。当SYN=1，ACK=0时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中SYN=1，ACK=1。
+ **终止FIN**：用来释放一个连接，当FIN=1时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。
+ **窗口**：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。



## TCP的三次握手

> 通过发送3个特殊的报文段完成一个 TCP 连接的建立的过程。
>
> 一个 TCP 连接是由一对套接字构成，其中通信的每一端都由一对（IP地址，端口号）所唯一标识。

<img src=".\计算机网络学习笔记\TCP三次握手.png" style="zoom:50%;" />

TCP 连接握手，**约定通信双方的 ISN** （Initial Sequence Number）初始序列号，以用于后面的接收和重传。

+ 首先 B 处于LISTEN（监听）状态，等待客户的连接请求。
+ A 向 B发送连接请求报文，SYN = 1，ACK = 0，选择一个**初始的序列号** x。
+ B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN = 1，ACK = 1，确认号为 x + 1，同时也选择一个**初始的序列号** y。
+ A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y +  1，序号为 x + 1。
+ B 收到 A 的确认后，连接建立。

**三次握手的原因**

> 通过三次握手来**确认双方都可以获得对方的初始序列号**，初始序列号是后面进行可靠重传或接收的基础。
>
> 为了在不可靠的信道上进行可靠的传输所必须采取的行为。

为了**防止已失效的连接请求报文段突然又传送到了服务端**，因而产生错误。

假设不采用“三次握手”，那么只有 server 发出确认，新的连接就建立了。由于现在 client 并没有发出建立连接的请求，因此不会理睬 server 的确认，也不会向 server 发送数据。但 server 却以为新的运输连接已经建立，并一直等待 client 发来数据。这样，server 的很多资源就白白浪费掉了。

这个问题的本质是, 信道不可靠, 但是通信双方需要就某个问题达成一致. 而要解决这个问题, 无论你在消息中包含什么信息, 三次通信是理论上的最小值. 所以三次握手不是TCP本身的要求, 而是为了满足"**在不可靠信道上可靠地传输信息**"这一需求所导致的.



## TCP的四次挥手

<img src=".\计算机网络学习笔记\TCP连接释放.jpg" style="zoom:50%;" />

+ A 发送连接释放报文，FIN = 1.
+ B 收到之后发出确认，此时 TCP 属于**半关闭**状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。
+ 当 B 不再需要连接时，发送连接释放报文，FIN = 1。
+ A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后**释放连接**。
+ B 收到 A 的确认后**释放连接**。



**四次挥手的原因**

四次挥手其实是客户端和服务端的两次挥手，也就是客户端和服务端**分别释放**连接的过程。

1）由于**客户端最后一个ACK可能会丢失**，这样 B 就无法正常进入 CLOSED 状态。于是 B 会重传请求释放的报文，而此时A如果已经关闭了，那就收不到 B 的重传请求，就会**导致B不能正常释放**。而如果 A 还在等待时间内，就会收到 B 的重传，然后进行应答，这样B就可以进入 CLOSED 状态了。

2）在这 2MSL 等待时间里面，本次连接的所有的报文都已经**从网络中消失**，从而不会出现在下次连接中。



## TCP可靠传输

TCP 主要通过以下四种方式实现可靠传输机制：

+ 校验

+ 序号

  TCP 是面向字节流的，每一个字节都对应着一个序号。在 TCP 首部中，有一个序号字段，指的就是一个报文段第一个字节的序号。有了序号，就能保证数据能够有序的传递给应用层。

+ 确认

  TCP 传输中发送的每一个报文，都必须被确认接收，若没有收到确认消息，则发送方会重新发送该报文。

+ 重传

  TCP 针对数据包丢失的情况，会采用重传机制解决。常见的重传机制有：

  + 超时重传
  + 快速重传
  + SACK

**超时重传**

> 在发送数据时，设定一个定时器，当计时时间到后，没有收到对方的 `ACK` 确认应答报文，就会重发该数据。

超时重传的关键在于**如何设定超时时间**，超时重传时间以 `RTO` （Retransmission Timeout 超时重传时间）表示，超时时间过长或过短都会带来相应的问题：

<img src=".\计算机网络学习笔记\超时时间过长或过短.jpg" style="zoom:50%;" />

鉴于以上的两种情况，超时重传时间 `RTO` 的值应该略大于报文往返 `RTT`（一个报文段从发送再到接收到确认所经过的时间） 的值。

实际上「报文往返 `RTT` 的值」是经常变化的，因为我们的网络也是时常变化的。也就因为「报文往返 `RTT` 的值」 是经常波动变化的，所以「超时重传时间 `RTO` 的值」应该是一个**动态变化的值**。



**快速重传**

> 与超时重传不同，快速重传（Fast Retransmit）不以时间为驱动，而是以数据驱动重传

<img src=".\计算机网络学习笔记\快速重传.jpg" style="zoom:50%;" />

快速重传的工作方式是当收到三个相同的 ACK 报文时，重传丢失的报文段。

快速重传的问题：重传的时候，是重传之前的一个，还是重传所有。



**SACK**

> `SACK（Selective Acknowledgment）`，即选择性确认

<img src=".\计算机网络学习笔记\选择性确认.jpg" style="zoom:50%;" />

这种方式需要在 TCP 头部选项字段里加一个 `SACK` 的东西，它可以将缓存的数据段发送给发送方，这样发送方就可以知道哪些数据收到了，哪些数据没收到，这样就可以只重传丢失的数据。



## TCP滑动窗口

> 窗口是**缓存**的一部分，是对用来**暂时存放**发送方和接收方之间流动的字节流的**缓存空间**的反映。
>
> TCP 以字节（而非包）为单位维护其窗口结构。

### 引入窗口机制的原因

> TCP 发送的每一个数据包，都需要进行确认应答。当上一个数据包收到应答后，再继续发送下一个。这种传输方式的通信效率太低。
>
> 有了窗口机制后，就能**一次发送窗口所能容纳的最大数量的数据包**。
>
> 窗口的实现实际上是操作系统开辟的一个缓存空间，发送方主机在等到确认应答返回之前，必须在缓冲区中保留已发送的数据。如果按期收到确认应答，此时确认的数据就可以从缓存区清除。
>
> 接收方主机在已发送确认并交付主机之前，必须在缓存区中保留已接收的数据。如果接收到的数据**已发送确认并交付主机，就可以从缓存区清除**。

### 发送方的滑动窗口

> 发送窗口用于记录可以发送的数据的范围，其大小反映了发送方当前**可以发送的最大数据量**，并受**接收端通知窗口**和**拥塞窗口**的控制。

TCP 发送方滑动窗口方案使用三个指针来跟踪在四个传输类别中的每一个类别中的字节。其中两个指针是绝对指针（指特定的序列号），一个是相对指针（需要做偏移）。

<img src=".\计算机网络学习笔记\TCP发送窗口.jpg" style="zoom:50%;" />

- `SND.WND`：表示发送窗口的大小（大小是由接收方指定的）；
- `SND.UNA`：是一个绝对指针，它指向的是已发送但未收到确认的第一个字节的序列号，也就是 #2 的第一个字节。
- `SND.NXT`：也是一个绝对指针，它指向未发送但可发送范围的第一个字节的序列号，也就是 #3 的第一个字节。
- 指向 #4 的第一个字节是个相对指针，它需要 `SND.UNA` 指针加上 `SND.WND` 大小的偏移量，就可以指向 #4 的第一个字节了。

### 接收方的滑动窗口

> 接收窗口用于记录**可以接收的数据的范围**，其大小反映了接收方当前的**可用缓存空间的大小**。

TCP 接收方滑动窗口方案使用两个指针来对接收的字节数据进行划分。其中一个绝对指针，一个相对指针。

<img src=".\计算机网络学习笔记\TCP接收窗口.jpg" style="zoom:50%;" />

- `RCV.WND`：表示接收窗口的大小，它会通告给发送方。
- `RCV.NXT`：是一个指针，它指向期望从发送方发送来的下一个数据字节的序列号，也就是 #3 的第一个字节。
- 指向 #4 的第一个字节是个相对指针，它需要 `RCV.NXT` 指针加上 `RCV.WND` 大小的偏移量，就可以指向 #4 的第一个字节了。

### 滑动窗口工作机制

**发送窗口范围**内的字节都**允许被发送**，**接收窗口范围**内的字节都**允许被接收**。

如果发送窗口左部的字节已经发送并且接收到了确认，那么就将发送窗口向右滑动一定距离，直到**左部第一个字节不是已发送并且已确认**的状态；接收窗口的滑动类似，接收窗口的**左部字节已经发送确认**，就向右滑动接收窗口。

接收窗口只会对**窗口内最后一个按序到达的字节进行确认**，例如接收窗口已经收到的字节为 {31， 34， 35}，其中 {31} 按序到达，而 {34， 35} 不是，因此只对字节31进行确认。**发送方在得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收**。



### 零窗口与 TCP 持续计时器

**零窗口**

>  如果窗口大小为 0 时，就会阻止发送方给接收方传递数据，直到窗口变为非 0 为止，这就是窗口关闭。

当发送窗口关闭时，接收方处理完数据后，会向发送方通告一个窗口非0的 ACK 报文，如果这个通告窗口的 ACK 报文在网络中丢失，发送方会一直等待接收方的非0窗口通知，接收方也一直等待发送方的数据，如不采取措施，这种相互等待的过程，会造成死锁的现象。

<img src=".\计算机网络学习笔记\窗口关闭危险.jpg" style="zoom:50%;" />

**TCP 持续计时器**

> TCP 为每个连接设有一个持续定时器，只要 TCP 连接一方收到对方的零窗口通知，就启动持续计时器。

如果持续计时器超时，就会发送窗口探测（Window probe）报文，而对方在确认这个探测报文时，给出自己现在的接收窗口大小。

<img src=".\计算机网络学习笔记\窗口探测.jpg" style="zoom:50%;" />





## TCP流量控制

> 流量控制是为了**控制发送方的发送速率（动态调节发送方窗口大小），保证接收方来得及处理**。
>
> 当发送方的发送速率**大于**接收方的处理速率时，将会导致**接收方缓存溢出**，因此需要控制发送方的发送速率。

接收方发送的**确认报文中的窗口字段**可以用来**控制发送方窗口大小**，从而影响发送方的发送速率。**接收方窗口的大小意味着接收方还有多大的缓冲区可以用于接收数据**。



## TCP拥塞控制

> 拥塞控制是为了当拥塞发生时，控制 TCP  传输速率，降低整个网络的拥塞程度。
>
> 当网络出现拥塞时，分组将会丢失，此时发送方需要重传，从而导致网络拥塞程度更高；因此，拥塞控制的基本思路是当认为网络即将进入拥塞状态（或者网络中间设备（路由器、交换机）已经由于拥塞而发生丢包情况）时减缓 TCP 传输。

TCP 拥塞控制难点：

+ **如何判断**拥塞状况已发生
+ **如何减缓** TCP 传输
+ **何时恢复** TCP 传输原有速度

基于对网络传输能力的估计，在发送端引入一个窗口控制变量，确保**发送窗口大小**不超过**接收端接收能力**和**网络传输能力**，即 TCP 发送端的发送速率等于接收速率和传输速率中的较小值。

反映网络传输能力的变量称为拥塞窗口（congestion window），记作 `cwnd`。因此，发送端实际窗口 W 就是接收端通知窗口 `awnd `和拥塞窗口 `cwnd` 的较小者：`W = min(cwnd, awnd)`。即 TCP 发送端已经发出但还未经确认的数据量大小（在外数据值），总是小于等于 W。

TCP 主要通过四个算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。

### 慢开始与拥塞避免

TCP 建立连接完成后，当发送方每收到一个 ACK，拥塞窗口 `cwnd `的大小就会加1（**慢开始**）；当拥塞窗口 `cwnd` 超过慢开始门限 `ssthresh`(slow start threshold) 时，每当收到一个 ACK 时，`cwnd` 增加 `1/cwnd`（**拥塞避免**）。 

<img src=".\计算机网络学习笔记\慢开始与拥塞避免.jpg" style="zoom:50%;" />

当 `cwnd` 按照这个规则一直增长下去，网络就会慢慢进入了拥塞的状况（**发生超时重传，就认为网络出现了拥塞**）了，于是就会出现丢包现象，这时就需要对丢失的数据包进行重传。

### 拥塞发生

> 当网络出现拥塞，也就是会发生数据包重传，重传机制主要有两种：
>
> + 超时重传
> + 快速重传

当发生了超时重传，这时 `ssthresh` 设为 `cwnd/2`，`cwnd` 重置为1，重新开始慢开始。

<img src=".\计算机网络学习笔记\拥塞发生—超时重传.jpg" style="zoom:50%;" />

当发生快速重传，这时`cwnd` 重置为原来的一半，`ssthresh` 设为 `cwnd`，进入快速恢复算法。



### 快速恢复

> 快速重传和快速恢复算法一般同时使用，在进入快速恢复之前，`cwnd` 和 `ssthresh` 已被更新：
>
> + `cwnd = cwnd/2`，也就是设置为原来的一半
> + `ssthresh = cwnd`

<img src=".\计算机网络学习笔记\拥塞发生—快速恢复.jpg" style="zoom:50%;" />

快速重传算法：

+ 拥塞窗口 `cwnd = ssthresh + 3` （ 3 的意思是确认有 3 个数据包被收到了）
+ 重传丢失的数据包
+ 进入拥塞避免

慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。



# 网络层

> 网络层提供**主机到主机**之间的无连接或者有连接服务，而不同时提供两种服务。仅提供**无连接**的网络称为**数据报网络**（Datagram Network），仅提供**有连接**的网络称为**虚电路网络**（Virtual-Circuit. VC）。
>
> TCP/IP 协议体系中的网络层功能由 IP 协议规定和实现，故又称为 IP 层。IP 层向上提供**无连接**的、**尽力而为**的**数据报**交付服务。

因特网的网络层有三个主要组件。第一个是 **IP 协议**，它是网络层的核心；第二个是**路由选择**部分，它决定了数据报从源到目的地所流经的路径；第三个是 **ICMP 协议**，用于报告数据报中的差错和对某些网络层信息请求进行响应。

<img src=".\计算机网络学习笔记\网络层内部视图.png" style="zoom: 80%;" />

使用 IP 协议，可以把异构的物理网络连接起来，使得在网络层看起来好像是一个统一的网络。

<img src=".\计算机网络学习笔记\网络层作用.png" style="zoom:50%;" />

与 IP 协议配套使用的还有三个协议：

+ 地址解析协议 ARP（Address Resolution Protocol）
+ 网际控制报文协议 ICMP（Internet Control Message Protocol）
+ 网际组管理协议 IGMP（Internet Group Management Protocol）



## IP 数据报格式

<img src=".\计算机网络学习笔记\IP数据报格式.jpg" style="zoom:50%;" />

+ **版本**：有 4（IPv4）和 6（IPv6）两个值。
+ **首部长度**：占 4 位，因此最大值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为固定部分长度为 20 字节，因此该值最小为 5。如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充。
+ **区分服务**：用来获得更好的服务，一般情况下不使用。
+ **总长度**：包括首部长度和数据部分长度。
+ **生存时间**：TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由跳数为单位，当 TTL 为 0 时就丢弃数据报。
+ **协议**：指出携带的数据应该上交给哪个协议进行处理，例如 ICMP、TCP、UDP等。
+ **首部检验和**：因为数据报每经过一个路由器，都要重新计算检验和，因此检验和不包含数据部分可以减少计算的工作量。
+ **标识**：在数据报长度过长而发生分片的情况下，相同数据报的不同分片具有想太多标识符。
+ **片偏移**：和标识符一起，用于发生分片的情况。片偏移的单位为 8 字节。

<img src=".\计算机网络学习笔记\数据报分片.png" style="zoom:50%;" />



## IP 地址编址方式

IP 地址的编址方式经历了三个历史阶段：

+ 分类
+ 子网划分
+ 无分类

### 1.分类

### 2.子网划分

### 3.无分类



## 地址解析协议 ARP

> 在以太网协议中规定，同一局域网中的一台主机要和另一台主机进行直接通信，必须要知道目标主机的 MAC 地址。而在TCP/IP 协议中，网络层和传输层只关心目标主机的 IP 地址。这就导致数据链路层的以太网协议接到上层 IP 协议提供的数据中，只包含目的主机的 IP 地址。于是需要一种方法，根据目的主机的 IP 地址，获得其 MAC 地址。这就是 ARP 协议要做的事情。

网络层实现主机之间的通信，而链路层实现具体每段链路之间的通信。因此在通信过程中，IP数据报的源地址和目的地址始终不变，而 MAC 地址随着链路的改变而改变。

<img src=".\计算机网络学习笔记\网络通信.jpg" style="zoom:50%;" />

ARP 实现由 IP 地址得到 MAC 地址。

<img src=".\计算机网络学习笔记\ARP协议作用.jpg" style="zoom:50%;" />

每个主机都有一个 ARP 高速缓存，里面有**本局域网**上的各主机和路由器的 IP 地址到 MAC 地址的映射表。

如果主机 A 知道主机 B 的 IP 地址，但是 ARP 高速缓存中没有该 IP 地址到 MAC 地址的映射，此时主机 A 通过广播的方式发送 ARP 请求分组，主机 B 收到该请求后会发送 ARP 响应分组给主机 A 告知其 MAC 地址，随后主机 A 向其高速缓存中写入主机 B 的 IP 地址到 MAC 地址的映射。

当发送主机和目的主机不在同一个局域网中时，即便知道对方的 MAC 地址，两者也不能直接通信，必须经过路由转发才可以。所以此时，发送主机通过 ARP 协议获得的将不是目的主机的真实 MAC地址，而是一台可以通往局域网外的路由器的 MAC 地址。

<img src=".\计算机网络学习笔记\地址解析协议 ARP 的工作原理.png" style="zoom:50%;" />

## 网际控制报文协议 ICMP

> IP 协议本身并没有提供方法来获取协议层配置和数据包处置相关的诊断和控制信息。
>
> 为了解决这些不足之处，将 ICMP 与 IP 结合使用，以便提供与 IP 数据包处置和 IP 协议层配置相关的诊断和控制信息。ICMP 报文使用 IP 协议传输，但它不属于高层协议，通常被认为是 IP 层的一部分。
>
> ICMP 是为了更有效地转发 IP 数据报和提高交付成功的机会。

<img src=".\计算机网络学习笔记\ICMP报文的格式.jpg" style="zoom:50%;" />

ICMP 报文分为两大类：

+ 差错报告报文（error message）：有关**IP数据报传递**
+ 查询或信息类报文（informational message）：有关**信息采集和配置**

<img src=".\计算机网络学习笔记\ICMP报文类型.png" style="zoom:50%;" />

### Ping

Ping 是 ICMP 的一个重要应用，主要用来测试两台主机之间的连通性。

其原理是通过向目的主机发送 ICMP Echo 请求报文，目的主机收到之后会发送 Echo 回答报文；Ping 会根据时间和成功响应的次数估算出数据包往返时间（RTT）以及丢包率。

**RTT 计算方法**

ping 程序在发出的回显请求报文的可选数据区域中包含了一份本地时间拷贝；被 ping 主机在返回回显应答报文时，请求报文中的数据区域中的内容会被包含在应答中。当应答收到时，ping 程序用当前时间减去应答中的时间，便得到了一个到达被 ping 主机的 RTT 估计值。



### Traceroute

Traceroute 是 ICMP 的另一个应用，用来跟踪一个分组从源点到终点的路径。

Traceroute 发送的 IP 数据报封装的是无法交付的 UDP 用户数据报（目的主机上没有应用程序准备好接受它），并由目的主机发送终点不可达差错报告报文。

- 源主机向目的主机发送一连串的 IP 数据报。第一个数据报 P1 的生存时间 TTL 设置为 1，当 P1 到达路径上的第一个路由器 R1 时，R1 收下它并把 TTL 减 1，此时 TTL 等于 0，R1 就把 P1 丢弃，并向源主机发送一个 ICMP 时间超过差错报告报文；
- 源主机接着发送第二个数据报 P2，并把 TTL 设置为 2。P2 先到达 R1，R1 收下后把 TTL 减 1 再转发给 R2，R2 收下后也把 TTL 减 1，由于此时 TTL 等于 0，R2 就丢弃 P2，并向源主机发送一个 ICMP 时间超过差错报文。
- 不断执行这样的步骤，直到最后一个数据报刚刚到达目的主机，主机不转发数据报，也不把 TTL 值减 1。但是因为数据报封装的是无法交付的 UDP，因此目的主机要向源主机发送 ICMP 终点不可达差错报告报文。
- 之后源主机知道了到达目的主机所经过的路由器 IP 地址以及到达每个路由器的往返时间。



## 虚拟专用网 VPN



## 网络地址转换 NAT



## 路由器

> 工作于网络层的分组交换机，提供**路由**与**转发**两种重要机制，可以决定数据包从来源端到目的端所经过的路径（host到host之间的传输路径），这个过程称为路由；将路由器输入端的数据包移送至适当的路由器输出端（在路由器内部进行），这称为转发。

### 结构

路由器从功能上可以划分为：路由选择和分组转发。

分组转发结构由三个部分组成：交换结构、一组输入端口和一组输出端口。

<img src=".\计算机网络学习笔记\典型的路由器结构.jpg" style="zoom: 67%;" />

### 分组转发

每台路由器都有一张转发表，路由器通过检查到达分组首部字段的值，然后使用该值在转发表中索引查询，得到该分组将被转发的路由器的输出链路接口，从而将该分组转发到该输出接口。

路由器中的转发表由路由选择算法决定。

![](.\计算机网络学习笔记\路由分组转发.png)



### 路由选择协议

> 路由选择协议的任务就是确定数据报在源与目的地之间采用的路径

因特网通过定义自治系统来解决规模与管理责任的问题。自治系统（AS）指的是一个处于相同的管理控制下的路由器的集合。互联网可以划分为许多较小的自治系统  AS，一个 AS 可以使用一种和别的 AS 不同的路由选择协议。

可以把路由选择协议划分为两大类：

+ 自治系统内部路由选择协议：RIP 和 OSPF

  > 用于确定在一个 AS 内执行路由选择的方式

+ 自治系统间路由选择协议：BGP

  > 自治系统间路由选择协议任务：
  >
  > + 从相邻 AS 获取可达性信息，即经相邻 AS 可达哪些目的地
  > + 向该 AS 中所有路由器传播可达性信息，这样 AS 内的每台路由器可以配置它的转发表以处理外部 AS 目的地

每台路由器接收一个 AS 内部路由选择协议和一个 AS 间路由选择协议的信息，并使用来自这两个协议的信息配置它的转发表。

![](.\计算机网络学习笔记\互联的自治系统.png)







# 链路层



# 物理层