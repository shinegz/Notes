<img src="D:\Notes\CS\数据结构与算法\数据结构与算法\刷题指南.jpg"  />

## 基本概念

### 数据结构

> 计算机中存储和组织数据的方式。

数据的结构包括逻辑结构和物理结构。

#### 逻辑结构

> 数据对象中数据元素之间的相互关系

可分为以下四种类型：

+ 集合结构：数据元素除了同属于一个集合外，它们之间再没有其他关系
+ 线性结构：数据元素之间是一对一的关系
+ 树形结构：数据元素之间是一对多的层次关系
+ 图形结构：数据元素之间是多对多的关系

#### 物理结构

可分为以下两种类型：

+ 顺序存储结构：数据元素存储在地址连续的存储单元里

+ 链式存储结构：数据元素存放在任意的存储单元里，不必连续



### 算法复杂度

> 算法的复杂度由两个维度来衡量：时间复杂度和空间复杂度

#### 计算方法

> 大O表示法：T(n)=O(f(n))，f(n)表示代码的执行次数之和，T(n)表示的是代码执行时间（占用内存）与数据规模之间的增长关系（当n逐渐增大时，代码执行时间（占用内存）的增长趋势）

大O表示法计算的是算法的渐进时间（空间）复杂度，即用另一个（通常更简单）函数来描述一个函数数量级（增长率）的渐近上界

#### 时间复杂度

> 算法执行时间的增长趋势

常用时间复杂度量级：

+ 常数阶O(1)
+ 对数阶O(logN)
+ 线性阶O(n)
+ 线性对数阶O(nlogN)
+ 平方阶O(n^2)
+ 立方阶O(n^3)
+ K次方阶O(n^k)
+ 指数阶O(2^n)
+ 阶乘阶O(n!)

#### 空间复杂度

> 算法占用内存空间的增长趋势

常用空间复杂度量级：

+ 常数阶O(1)
+ 线性阶O(n)
+ 平方阶O(n^2)



## 数据结构

### 数组

> 顺序（连续）存储结构的线性表，每个元素都有一个唯一的索引
>
> **数组的访问效率较高，而插入效率较低**

#### 添加数组元素的方法

+ unshift（首部添加）
+ push（尾部添加）
+ splice（任意位置）

#### 删除数组元素的方法

+ shift（首部删除）
+ pop（尾部删除）
+ splice（任意位置）

### 字符串

### 栈

> 后进先出（Last in First out）的线性表（限定了操作的线性表），且只能在栈尾进行添加删除操作



### 队列

> 先进先出（First in First out）的线性表（限定了操作的线性表），且只能在队尾添加，在队首删除

<img src=".\数据结构与算法\队列FIFO.png" style="zoom:50%;" />

#### 双端队列

> 允许在队列的两端进行插入和删除的队列



### 链表

> 链式（离散）存储结构的线性表，链表中的每个节点（元素）由数据域（存储值）和指针域（指向下一个节点）组成
>
> **链表的插入/删除效率较高，而访问效率较低**

+ 删除链表中的节点

  > 两种方法：
  >
  > + 已知待删除节点的前驱节点：`pre.next = cur.next`
  > + 待删除节点的前驱节点未知：`cur.val = cur.next.val; cur.next = cur.next.next`

+ 反转链表（多指针|递归）

  > 定义三个指针`pre`，`cur`，`next`
  >
  > `pre`和`cur`用于反转节点的指针指向，`next`指针用于保存`cur`的下一个节点



### 符号表

#### 初级实现

#### 二叉搜索树

#### 红黑树

#### 散列表



### 图

> 图由一组顶点和一组能够将两个顶点相连的边组成

#### 有向图

> 连接顶点的边具有方向性的图

##### 拓扑排序

给定一个包含 n 个节点的有向图 G，我们给出它的节点编号的一种排列，如果满足：

> 对于图 G 中的任意一条有向边 (u, v)，u 在排列中都出现在 v 的前面。

那么称该排列是图 G 的「拓扑排序」。根据上述的定义，我们可以得出两个结论：

+ 如果图 *G* 中存在环（即图 *G* 不是「有向无环图」），那么图 *G* 不存在拓扑排序。
+ 如果图 *G* 是有向无环图，那么它的拓扑排序可能不止一种。

#### 无向图

> 连接顶点的边没有方向性的图



### 树

> 由n（n>0）个有限节点组成一个具有层次关系的集合。

它具有以下的特点：

- 每个节点都只有有限个子节点或无子节点；
- 没有父节点的节点称为根节点；
- 每一个非根节点有且只有一个父节点；
- 除了根节点外，每个子节点可以分为多个不相交的子树；
- 树里面没有环路(cycle)

#### 树的相关概念

- 树的层次计算规则：根结点所在的那一层记为第一层，其子结点所在的就是第二层，以此类推。
- 结点和树的“高度”计算规则：叶子结点高度记为1，每向上一层高度就加1，逐层向上累加至目标结点时，所得到的的值就是目标结点的高度。树中结点的最大高度，称为“树的高度”。
- “度”的概念：一个结点开叉出去多少个子树，被记为结点的“度”。
- “叶子结点”：叶子结点就是度为0的结点。

#### 二叉树

> 每个节点最多含有两个子树的树

##### 二叉树的遍历

按顺序规则划分：

+ 先序遍历：**根节点** -> 左子树 -> 右子树

  <img src=".\数据结构与算法\二叉树前序遍历.png" style="zoom:50%;" />

+ 中序遍历：左子树 -> **根节点** -> 右子树

  <img src=".\数据结构与算法\二叉树中序遍历.png" style="zoom:50%;" />

+ 后序遍历：左子树 -> 右子树 -> **根节点**

  <img src=".\数据结构与算法\二叉树的后序遍历.png" style="zoom:50%;" />

+ 层序遍历

按实现方式划分：

+ 递归遍历（前、中、后遍历）
+ 迭代遍历（层次遍历）



##### 二叉搜索树（BST）

> 1. 是一棵空树
> 2. 是一棵由根结点、左子树、右子树组成的树，同时左子树和右子树都是二叉搜索树，且**左子树**上所有结点的数据域都**小于等于**根结点的数据域，**右子树**上所有结点的数据域都**大于等于**根结点的数据域
>
> 满足以上两个条件之一的二叉树，就是二叉搜索树。

二叉搜索树的特性：中序遍历结果为有序数组

常见考点：

+ 查找数据域为某一特定值的结点

  ```javascript
  /**
   * @param {TreeNode} root
   * @param {number} val
   * @return {TreeNode}
   */
  var searchBST = function(root, val) {
      if (!root) {
          return null;
      }
  
      if (root.val === val) {
          return root;
      } else if (root.val > val) {
          return searchBST(root.left, val);
      } else {
          return searchBST(root.right, val);
      }
  };
  ```

+ 插入新结点

  ```javascript
  /**
   * @param {TreeNode} root
   * @param {number} val
   * @return {TreeNode}
   */
  var insertIntoBST = function(root, val) {
      // 递归边界
     if (!root) {
         return new TreeNode(val);
     }
  
     if (root.val > val) {
         root.left = insertIntoBST(root.left, val);
     } else {
         root.right = insertIntoBST(root.right, val);
     }
  
     return root;
  };
  ```

+ 删除指定结点

  ```javascript
  /**
   * @param {TreeNode} root
   * @param {number} key
   * @return {TreeNode}
   */
  var deleteNode = function(root, n) {
      if (!root) {
          return null;
      }
  
      if (root.val === n) {
          // 目标节点为叶子节点
          if (!root.left && !root.right) {
              root = null;
          } else if (root.left) {
              const maxLeft = findMax(root.left);
              root.val = maxLeft.val;
              root.left = deleteNode(root.left, maxLeft.val);
          } else {
              const minRight = findMin(root.right);
              root.val = minRight.val;
              root.right = deleteNode(root.right, minRight);
          }
      } else if (root.val > n) {
          root.left = deleteNode(root.left, n);
      } else {
          root.right = deleteNode(root.right, n);
      }
  
      return root;
  };
  
  function findMax (root) {
      while (root.right) {
          root = root.right;
      }
  
      return root;
  }
  
  function findMin (root) {
      while (root.left) {
          root = root.left
      }
  
      return root;
  }
  ```

+ 二叉搜索树的判定

  ```javascript
  /**
   * @param {TreeNode} root
   * @return {boolean}
   */
  var isValidBST = function(root) {
      
      function dfs (root, minValue, maxValue) {
          if (!root) {
              return true;
          }
  
          if (root.val <= minValue || root.val >= maxValue) return false;
  
          return dfs(root.left, minValue, root.val) && dfs(root.right, root.val, maxValue);
      }
  
      return dfs(root, -Infinity, +Infinity);
  };
  ```

  



##### 平衡二叉树（AVL Tree）

> **任意结点**的**左右子树高度差绝对值都不大于1**的二叉**搜索树**

常见考点：

+ 平衡二叉树的判定

  > 平衡二叉树中的任一节点的左右子树的高度差的绝对值不大于1。

  ```javascript
  /**
   * @param {TreeNode} root
   * @return {boolean}
   */
  var isBalanced = function(root) {
      let flag = true;
  
      function dfs (root) {
          if (!root) {
              return 0;
          }
  
          const left = dfs(root.left) + 1;
          const right = dfs(root.right) + 1;
  
          if (Math.abs(left - right) > 1) flag = false;
  
          return Math.max(left, right);
      }
  
      dfs(root);
  
      return flag;
  };
  ```

+ 平衡二叉树的构造（一般是将一颗二叉搜索树转换为平衡二叉树）

  > 思路：先对二叉搜索树进行中序遍历得到一个有序数组（利用了二叉搜索树的特性），再根据有序数组构造平衡二叉树。

##### 完全二叉树

> 1、从第一层到倒数第二层，每一层都是满的，也就是说每一层的节点数都达到了当前层所能达到的最大值
>
> 2、最后一层的节点是从左到右连续排列的，不存在跳跃排列的情况（也就是说这一层的所有节点都集中排列在最左边）

<img src=".\数据结构与算法\完全二叉树.jpg" style="zoom:50%;" />

##### 堆

> 堆是完全二叉树的一种特例。
>
> 根据约束规则的不同，堆又分为两种：
>
> + 大顶堆：完全二叉树中的每个节点的节点值不小于其左右孩子的节点值
> + 小顶堆：完全二叉树中的每个节点的节点值不大于其左右孩子的节点值

**堆（大顶堆）操作**

+ 取出堆顶元素（删除操作）**向下对比+交换**
+ 往堆中添加一个元素（插入操作）**向上对比+交换**

<img src=".\数据结构与算法\大顶堆.jpg" style="zoom:50%;" />

假如我们从左到右、从上到下依次对大顶堆中的结点从0开始进行编码：

<img src=".\数据结构与算法\编码后的大顶堆.jpg" style="zoom:50%;" />

那么对于索引为 `n` 的结点来说：

1. 索引为 `(n-1)/2` 的结点是它的父结点
2. 索引` 2*n+1` 的结点是它的左孩子结点
3. 索为引` 2*n+2` 的结点是它的右孩子结点

堆的层序遍历序列：[9, 8, 6, 3, 1]

**取出堆顶元素**

1. 用堆里的最后一个元素（对应图中的数字1）替换掉堆顶元素。
2. 对比新的堆顶元素（1）与其左右孩子的值，如果其中一个孩子大于堆顶元素，则交换两者的位置。

不断进行上述的**向下对比+交换**的过程

```javascript
// 入参是堆元素在数组里的索引范围，low表示下界，high表示上界
function downHeap(low, high) {
    // 初始化 i 为当前节点，j 为当前节点的左孩子
    let i = low, j = i * 2 + 1
    // 当 j 不超过上界时，重复向下对比+交换的操作
    while(j <= high) {
        // 如果右孩子比左孩子更大，则用右孩子和根节点比较
        if (j + 1 <= high && heap[j + 1] > heap[j]) {
            j = j + 1
        }
        
        // 若当前节点比孩子节点小，则交换两者的位置，把较大的节点“拱上去”
        if (heap[i] < heap[j]) {
            // 交换位置
            const temp = heap[j]
            heap[j] = heap[i]
            heap[i] = temp
            
            // i 更新为被交换的孩子节点的索引
            i = j
            // j 更新为孩子节点的左孩子的索引
            j = j * 2 + 1
        } else {
            break
        }
    }
}
```

**往堆里追加一个元素**

1. 新来的数据首先要追加到当前堆里最后一个元素的后面。
2. 不断进行**向上对比+交换**的操作：如果发现追加的元素比父节点的节点值要大，那么就和父节点的元素相互交换，再接着往上进行比较，直到无法再继续交换为止。

```javascript
// 入参是堆元素在数组里的索引范围，low表示下界，high表示上界
function upHeap(low, high) {
    // 初始化 i（当前节点索引）为上界
    let i = high
    // 初始化 j 为 i 的父节点
    let j = Math.floor((i - 1) / 2)
    // 当 j 不逾越下界时，重复向上对比+交换的过程
    while(j >= low) {
        // 若当前节点比父节点大
        if (heap[j] < heap[i]) {
            // 交换当前节点与父节点，保持父节点是较大的一个
            const temp = heap[j]
            heap[j] = heap[i]
            heap[i] = temp
            
            // i 更新为被交换父节点的位置
            i = j
            // j 更新为父节点的父节点
            j = Math.floor((i - 1) / 2)
        } else {
            break
        }
    }
}
```



###### 优先队列

上面的堆的层序遍历序列就是一个优先队列。

优先队列的本质是二叉堆结构，它具有以下特性：

+ 队列的头部元素，也即索引为0的元素，就是整个数组里的最值——最大值或者最小值
+ 对于索引为`i`的元素来说，它的父节点小标是`(i - 1)/2`
+ 对于索引为`i`的元素来说，它的左孩子下标为`2*i+1`，右孩子下标应为`2*i+2`





### 并查集

> 由一系列不相交的集合组成，支持合并和查询两种操作。该数据结构主要用于解决一些元素分组的问题。
>
> + 合并（Union）：把两个不相交的集合合并为一个集合。
> + 查询（Find）：查询两个元素是否在同一个集合中。

集合A：1（代表元素）、2、3；1、2的父节点为1

集合B：4（代表元素）、5、6；5、6的父节点为4

<img src=".\数据结构与算法\并查集.jpg" style="zoom:50%;" />

```javascript
// 并查集类
function UnionFind (grid) {
    // 存放元素的父节点
    this.parent = []
    // 存放元素的秩（以该元素为根节点的子树的深度）
    this.rank = []

    let row = grid.length
    let col = grid[0].length

    for (let i = 0; i < row; i++) {
        for (let j = 0; j < col; j++) {
            if (grid[i][j] === '1') {
                this.parent[i * col + j] = i * col + j
            }
            this.rank[i * col + j] = 1
        }
    }
}

// 查找指定元素所在集合的代表元素（父节点为自身的元素）
UnionFind.prototype.find = function (x) {
    // 找到代表元素并返回，结束递归
    return this.parent[x] === x ? x : (this.parent[x] = this.find(this.parent[x]))
}

// 将两个元素所在的集合合并（如果两个元素不属于同一个集合）
UnionFind.prototype.union = function (x, y) {
    let rootX = this.find(x)
    let rootY = this.find(y)

    // x, y分别属于两个集合（代表元素不同）
    if (rootX !== rootY) {
        if (this.rank[rootX] < this.rank[rootY]) {
            this.parent[rootX] = rootY
        } else if (this.rank[rootX] > this.rank[rootY]) {
            this.parent[rootY] = rootX
        } else {
            this.parent[rootX] = rootY
            this.rank[rootY] += 1
        }
    }
}
```





## 算法

### 排序与查找

#### 优先队列/堆

> 当出现"第k大"或者”第k小“这样的关键字时，就需要用优先队列/堆结构。这样的手法可以允许我们在不对序列进行完全排序的情况下，找到第k个最值。

> 题目描述：在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。

```javascript
/**
* @param {number[]} nums
* @param {number} k
* @return {number}
*/
// 使用小顶堆实现
const findKthLargest = function(nums, k) {
    // 初始化一个堆数组
    const heap = []
    // n表示堆数组里当前最后一个元素的索引
    let n = 0
    // 缓存nums的长度
    const len = nums.length
    // 初始化大小为k的堆
    function createHeap() {
        for (let i = 0; i < k; i++) {
            // 逐个往堆里插入数组中的数字
            insert(nums[i])
        }
    }
    
    // 尝试用[k, n-1]区间的元素更新堆
    function updateHeap() {
        for (let i = k; i < len; i++) {
            // 只有比堆顶元素大的才有资格进堆
            if (nums[i] > heap[0]) {
                // 用较大数字替换堆顶数字
                heap[0] = nums[i]
                // 重复向下对比+交换的逻辑
                downHeap(0, k)
            }
        }
    }
    
    // 向下对比函数
    function downHeap(low, high) {
        // 入参是堆元素在数组里的索引范围，low表示下届，high表示上界
        let i = low, j = 2*i + 1
        // 当j不超过上界时，重复向下对比+交换的操作
        while(j <= high) {
            // 如果右孩子比左孩子更小，则用右孩子和根节点比较
            if (j + 1 <= high && heap[j + 1] < heap[j]) {
       			j = j + 1         
            }
            
            // 若当前节点比孩子节点大，则交换两者的位置，把较小的节点“拱上去”
            if (heap[i] > heap[j]) {
                // 交换位置
                const temp = heap[j]
                heap[j] = heap[i]
                heap[i] = temp
                
                // i更新为被交换的孩子节点的索引
                i = j
                // j更新为孩子节点的左孩子的索引
                j = j*2 + 1
            } else {
                break
            }
        }
    }
    
    // 入参是堆元素在数组里的索引范围，low表示下界，high表示上界
    function upHeap(low, high) {
        // 初始化i（当前节点索引）为上界
        let i = high
        // 初始化j为i的父节点
        let j = Math.floor((i - 1)/2)
        // 当j不逾越下界时，重复向上对比+交换的过程
        while(j >= low) {
            // 若当前节点比父节点小
            if (heap[j] > heap[i]) {
                // 交换当前节点与父节点，保持父节点是较小的一个
                const temp = heap[j]
                heap[j] = heap[i]
                heap[i] = temp
                
                // i更新为被交换父节点的位置
                i = j
                // j更新为父节点的父节点
                j = Math.floor((i-1)/2)
            } else {
                break
            }
        }
    }
    
    // 插入操作=将元素添加到堆尾部+向上调整元素的位置
    function insert(x) {
        heap[n] = x
        upHeap(0, n)
        n++
    }
    
    // 调用createHeap初始化元素个数为k的堆
    createHeap()
    // 调用updateHeap更新堆的内容，确保最后堆里保留的是最大的k个元素
    updateHeap()
    // 最后堆顶留下的就是最大的k个元素中最小的那个，也就是第k大的元素
    return heap[0]
}
```



#### 二分查找

> 二分查找的每一步都将搜索空间减半，二分查找的关键在于找到缩小区间的条件



#### 散列表

#### 二叉搜索树

#### 红黑二叉搜索树



### 双(多)指针

> 通过指针来缓存一些有用的信息



### 图与树的遍历

#### 递归

> 当一个函数直接或间接的调用自身时，这个函数就称为递归函数。
>
> 递归函数的两要素：
>
> + 递归式（重复的内容）
> + 递归边界（停止继续调用自身的条件）

#### DFS

> 深度优先搜索（Depth-First-Search，DFS）是一种用来遍历或搜索树或图的算法。DFS强调**尽可能深**的搜索树的分支（不撞南墙不回头）。

#### BFS

#### 回溯

> 一种用于搜索一个问题所有的解的算法，通过**深度优先搜索思想实现**。用一个**不断变化**的变量，在尝试各种可能的过程中，搜索需要的结果，强调**回退**操作对于搜索的合理性。
>
> 剪枝：
>
> 在遍历的时候，如果能够提前知道这一条分支不能搜索到满意的结果，就可以提前结束，这一步操作称为 **剪枝**

**解题步骤**

> 1. 找坑位，画树形逻辑模型
> 2. 填坑位，确定递归式和递归边界
> 3. 根据解的限制条件，确定剪枝策略（非必须步骤）

##### 与动态规划的区别

**共同点**
用于求解多阶段决策问题。多阶段决策问题即：

+ 求解一个问题分为很多步骤（阶段）；
+ 每一个步骤（阶段）可以有多种选择。

**不同点**

+ 动态规划只需要求我们评估最优解是多少，最优解对应的具体解是什么并不要求。因此很适合应用于评估一个方案的效果；
+ 回溯算法可以搜索得到所有的方案（当然包括最优解），但是本质上它是一种遍历算法，时间复杂度很高。



### 动态规划

> 解题一般步骤：
>
> + 确定状态
> + 找到转移公式
> + 确定初始条件以及边界条件
> + 计算结果



### 贪心



### 拓扑排序







## 解题模板

确定解题模板的思路

+ 什么时候用？（明确场景）
+ 为什么这样用？（提供依据）
+ 怎么用？（细化步骤）

### 递归与回溯问题解题模板

#### 什么时候用

看两个特征：

+ 题目中暗示了一个或多个解，并且要求我们详细地列举出每一个解的内容时，一定要想到递归回溯
+ 题目经分析后，可以转化为树形逻辑模型求解

#### 为什么这样用

递归与回溯的过程，本身就是穷举的过程。题目中要求我们列举每一个解的内容，解从哪来，解是基于穷举思想，对搜索树进行适当地剪枝后得来的

#### 怎么用（找“坑位”，画树形逻辑模型）

**一个模型——树形逻辑模型**；两个要点——递归式和递归边界。
树形逻辑模型的构建，**关键在于找“坑位”，一个坑位就对应树中的一层（坑位往往是哪些不会变的东西）**，每一层的处理逻辑往往是一样的，这个逻辑就是递归式的内容。至于递归边界，要么在题目中约束得非常清楚、要么默认为**“坑位”数量的边界**。 
用伪代码总结一下编码形式，大部分的题解都符合以下特征： 

```javascript
function xxx(入参) {
  前期的变量定义、缓存等准备工作 

  // 定义路径栈
  const path = []

  // 进入 dfs
  dfs(起点)

  // 定义 dfs 递归的过程就是去填坑的过程
  dfs(递归参数(坑位)) {
    if(到达了递归边界) {
      结合题意处理边界逻辑，往往和 path 内容有关
      return
    }
    
    // 注意这里也可能不是 for，视题意决定
    // 填坑
    for(遍历坑位的可选值) {
      path.push(当前选中值)
      处理坑位本身的相关逻辑
      path.pop()
    }
  }
}
```