## 浏览器架构演化

> 安全、快速和稳定是其架构演化的方向

### 进程和线程

**进程**

> 一个进程（process）就是一个程序的**运行**实例，为线程提供容器。启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫进程。
>
> 操作系统为一个**运行程序**分配的**资源的集合**。

**线程**

> **线程**（thread）是进程中的实际运作单位，它由进程来启动和管理。

**进程与线程之间的关系**

```javascript
A = 1+2
B = 20/0
C = 7*8
```

<img src=".\浏览器工作原理-geek\单线程与多线程的进程对比.png" style="zoom:50%;" />

+ 进程中的任意一线程执行出错，都会导致整个进程的崩溃

+ 线程之间共享进程中的数据。

  <img src=".\浏览器工作原理-geek\线程之间共享进程中的数据.png" style="zoom:50%;" />

+ 当一个进程关闭之后，操作系统会回收进程所占用的内存

+ 进程之间的内容相互隔离



### 单进程

> 浏览器的所有功能模块都是运行在同一个进程里

<img src=".\浏览器工作原理-geek\单进程浏览器架构.png" style="zoom:50%;" />

问题：

+ **不稳定**

  > 所有模块都运行在一个进程中，插件等任意出现问题的模块的意外崩溃会导致整个浏览器进程的崩溃。

+ **不流畅**

  > 所有页面的渲染模块、JavaScript执行环境以及插件都运行在同一个线程中，容易发生线程阻塞，进而导致整个浏览器变得卡顿甚至失去响应。

+ **不安全**

  > 插件可以获取到操作系统的任意资源，引发安全性问题；
  >
  > 页面脚本可以通过浏览器漏洞获取系统权限，引发安全性问题。



### 多进程

> 浏览器的各功能模块分别运行在不同进程中

#### 早期

<img src=".\浏览器工作原理-geek\早期多进程浏览器架构.png" style="zoom:50%;" />

解决单进程中问题的方法：

+ **不稳定**

  > 浏览器中的各功能模块运行在不同的进程中，由于进程是互相隔离的，当一个页面或者插件崩溃时，影响的仅是当前的页面进程或插件进程，并不会影响到浏览器和其他页面。

+ **不流畅**

  > 多进程架构中，每个页面对应一个渲染进程，JavaScript线程运行在渲染进程中，所以即使发生阻塞，影响的也只是当前的渲染页面，并不会影响到浏览器和其他页面。

+ **不安全**

  > 渲染进程和插件进程运行在安全沙箱中，使得它们无法获取系统权限和资源。

#### 目前

<img src=".\浏览器工作原理-geek\目前多进程浏览器架构.png" style="zoom:50%;" />

+ 浏览器进程：主要负责界面显示、用户交互、子进程管理和提供存储等功能。
+ 渲染进程：核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。
+ GPU进程：其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。
+ 网络进程：主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。
+ 插件进程：主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。

#### 优点

> 多进程模型提升了浏览器的**稳定性**、**流畅性**和**安全性**。

#### 缺点

+ 更高的资源占用。因为每个进程都会包含公共基础结构的副本（如 JavaScript 运行环境），这就意味着浏览器会消耗更多的内存资源。
+ 更复杂的体系架构。浏览器各模块之间耦合性高、扩展性差等问题，会导致现在的架构已经很难适应新的需求了。



### 面向服务

> Services Oriented Architecture。Chrome 整体架构会朝向现代操作系统所采用的“面向服务的架构” 方向发展，原来的各种模块会被重构成独立的服务（Service），每个服务（Service）都可以在独立的进程中运行，访问服务（Service）必须使用定义好的接口，通过 IPC（Inter-process communication） 来通信，从而构建一个更内聚、松耦合、易于维护和扩展的系统，更好实现 Chrome 简单、稳定、高速、安全的目标。

<img src=".\浏览器工作原理-geek\面向服务的浏览器架构.png" style="zoom:50%;" />



## 浏览器工作流程

> 从输入URL到页面完整展示

![](D:.\浏览器工作原理-geek\输入URL到页面展示完整流程.png)

### 用户输入

根据地址栏的输入做出不同的处理：

+ 输入为搜索内容

  使用浏览器默认的搜索引擎，来合成新的带搜索关键字的URL

+ 请求的URL

  处理为完整的URL

### URL请求

在得到URL后，浏览器主进程会通过进程间通信把URL请求发送至网络进程，网络进程在接收到URL请求后，会在这里发起真正的URL请求流程。

<img src=".\浏览器工作原理-geek\HTTP请求流程.png" style="zoom:50%;" />

等到网络进程接收到响应数据后，便解析响应头数据，并将数据转发给浏览器主进程，浏览器根据响应头进行下一步的处理：

+ 重定向

  在导航过程中，如果服务器响应行的状态码包含了301、302一类的跳转信息，浏览器会跳转到新的地址继续导航；

  如果响应行是200，那么浏览器可以继续处理该请求。

+ 响应数据类型处理

  如果响应头字段`Content-Type`的值被浏览器判断为下载类型，那么该请求会被提交给浏览器的下载管理器，同时URL请求的导航流程就此结束。

  如果是HTML，那么浏览器会继续进行导航流程。

### 准备渲染进程

> 默认情况下，Chrome会为每一个页面分配一个渲染进程。但如果**从一个页面打开了另一个新页面**，而**新页面和当前页面属于同一站点（协议和根域名相同）**的话，那么**新页面会复用父页面的渲染进程**。

### 提交文档

> 所谓提交文档，就是指浏览器进程将网络进程接收到的HTML数据提交给渲染进程。

具体流程：

+ 首先当浏览器进程**接收到网络进程的响应头数据**后，便向**渲染进程**发起“**提交文档**”的消息
+ 渲染进程在**接收到“提交文档”的消息**后，**会和网络进程建立传输数据的“管道”**
+ 等**文档数据传输完成**后，渲染进程会返回**“确认提交”的消息给浏览器进程**
+ 浏览器进程在**收到“确认提交”**的消息后，会**更新浏览器界面状态**，包括安全状态、地址栏的URL、前进后退的历史状态，并**更新Web页面**

### 渲染阶段

> 一旦文档被提交，渲染进程便开始页面解析和子资源加载，一旦页面生成完成，渲染进程会发送一个消息给浏览器主进程，浏览器接收到消息后，会停止标签图标上的加载动画



## 渲染

> 将HTML、CSS、JavaScript等数据转化为页面（位图）的过程。

### 渲染流水线

> 按照渲染的时间顺序，渲染流水线（将HTML转化为像素的处理流程）可分为如下几个子阶段：**构建DOM树**、**样式计算**、**布局阶段**、**分层**、**绘制**、**分块**、**光栅化和合成**。

<img src=".\浏览器工作原理-geek\完整的渲染流水线.png" style="zoom:50%;" />

结合上图，一个完整的渲染流程大致可总结为如下：

+ 渲染进程将 HTML 内容转换为能够读懂的 **DOM 树**结构。
+ 渲染引擎将 CSS 样式表转化为浏览器可以理解的 **styleSheets**，计算出 DOM 节点的样式。
+ 创建**布局树**，并计算元素的布局信息。
+ 对布局树进行分层，并生成**分层树**。
+ 为每个图层生成**绘制列表**，并将其提交到合成线程。
+ 合成线程将图层分成**图块**，并在**光栅化线程池**中将图块转换成位图。
+ 合成线程发送绘制图块命令 **DrawQuad** 给浏览器进程。
+ 浏览器进程根据 DrawQuad 消息**生成页面**，并**显示**到显示器上。

#### 构建DOM树

> 将HTML转换为浏览器能够理解的结构——DOM树

<img src=".\浏览器工作原理-geek\DOM树构建.png" style="zoom:50%;" />

#### 样式计算

> 计算出DOM节点中每个元素的具体样式

**1.把CSS转换为浏览器能够理解的结构**

> 将css文本转换为浏览器可以理解的结构——StyleSheet

**2.转换样式表中的属性值，使其标准化**

> 对styleSheet中的属性值转换为标准值

<img src=".\浏览器工作原理-geek\标准化属性值.png" style="zoom:50%;" />

**3.计算出DOM树中每个节点的具体样式**

> 根据继承和层叠规则，得到DOM元素的最终样式

<img src=".\浏览器工作原理-geek\样式树.png" style="zoom:50%;" />

#### 布局

> 计算DOM树中**可见元素**的**几何信息**的过程叫布局（layout）
>
> 在布局阶段有两个任务：创建布局树（LayoutTree）和布局计算

**1.创建布局树**

<img src=".\浏览器工作原理-geek\布局（渲染）树.png" style="zoom:50%;" />

**2.布局计算**



#### 分层

> 为了实现诸如3D变换、页面滚动，或者根据z-index做z轴排序等效果，渲染引擎需要为布局树中特定的节点生成专用的图层，并生成一颗对应的图层树（LayerTree）

<img src=".\浏览器工作原理-geek\布局树和图层树关系.png" style="zoom:50%;" />

通常情况下，并不是布局树中的每一个节点都包含一个图层，如果一个节点没有对应的图层，那么这个节点就从属于父节点的图层。

创建新图层的条件：

+ 拥有层叠上下文属性的元素
+ 需要剪裁的地方



#### 图层绘制

> 在完成图层树的构建后，渲染引擎会对图层树中的每个图层进行绘制

渲染引擎会把一个图层的绘制拆分成很多小的绘制指令，然后再把这些指令按照顺序组成一个待绘制列表。

绘制列表只是用来**记录绘制顺序和绘制指令的列表**，而实际上**绘制操作是由渲染引擎中的合成线程来完成的**。

<img src=".\浏览器工作原理-geek\绘制列表.png" style="zoom:50%;" />

#### 栅格化（raster）

> 所谓栅格化，是指将图块转换为位图

通常一个页面可能很大，但用户只能通过视口看到其中的一部分，所以在这种情况下，要绘制出所有的图层内容的话，就会产生太大的开销，而且也没有必要。

基于这个原因，合成线程会将图层划分为图块（tile）。

<img src=".\浏览器工作原理-geek\图层被划分为图块.png" style="zoom:50%;" />

然后合成线程会按照**视口附近的图块来优化生成位图**，实际生成位图的操作是由栅格化来执行的。

图块是栅格化执行的最小单位。渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的，运行方式如下图：

<img src=".\浏览器工作原理-geek\GPU栅格化.png" style="zoom:50%;" />

#### 合成和显示

> 一旦所有的图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。
>
> 浏览器在收到命令后，将页面绘制到内存中，最后再将内存显示在屏幕上。



## V8工作原理

### 数据存储机制

> JavaScript是一门动态、弱类型的语言

#### 语言类型

+ 静态VS动态
  + 静态：在代码执行前确定变量类型
  + 动态：在运行过程中确定变量类型
+ 强类型VS弱类型
  + 强类型：不支持隐式类型转换
  + 弱类型：支持隐式类型转换

#### 数据类型

<img src=".\浏览器工作原理-geek\数据类型.png" style="zoom:50%;" />

#### 内存模型

> 在 JavaScript 的执行过程中，主要有三种类型内存空间，分别是代码空间、栈空间和堆空间。

栈空间

> 用于存储执行上下文

堆空间

> 用于存储大的数据

<img src=".\浏览器工作原理-geek\JavaScript中数据存储机制.png" style="zoom:50%;" />

值的存储

> 原始类型的数据值直接存储在栈内存中，引用类型的值存放在堆内存中，栈中存储的是该值在堆内存中的地址。

赋值

> 原始类型的赋值会完整复制变量值，而引用类型的赋值是复制引用地址



### 垃圾回收

> 不再需要的数据称为垃圾数据。在JavaScript中，垃圾数据是由垃圾回收器来释放的。

#### 栈中的垃圾数据回收

> 当一个函数执行完毕时，JavaScript 引擎会通过向下移动 ESP（记录当前执行状态的指针）来销毁该函数保存在栈中的执行上下文。

#### 堆中的垃圾数据回收

> 堆内存中的垃圾数据需要通过**垃圾回收器**回收

##### 相关概念

**代际假说（The Generational Hypothesis）**

+ 大部分对象在内存中存在的时间很短，简单来说，就是很多对象一经分配内存，很快变得不可访问
+ 不死的对象，会活的更久

**新生代和老生代（基于代际假说）**

> 在 V8 中会把堆分为新生代和老生代两个区域，新生代中存放的是生存时间短的对象，老生代中存放的是生存时间久的对象

**活动对象和非活动对象**

+ 活动对象：还在使用的对象
+ 非活动对象：可以进行垃圾回收的对象



##### 垃圾回收器

###### 种类

+ 副垃圾回收器：主要负责新生代的垃圾回收
+ 主垃圾回收器：主要负责老生代的垃圾回收

###### 工作流程

1. 标记空间中活动对象和非活动对象。

2. 回收非活动对象所占据的内存

3. 做内存整理

   > 一般来说，频繁回收对象后，内存中就会存在大量不连续空间，我们把不连续的内存空间称为内存碎片。当内存中出现了大量的内存碎片之后，如果需要分配较大连续内存的时候，就有可能出现内存不足的情况。所有最后一步需要整理这些内存碎片。

###### 副垃圾回收器

> 副垃圾回收器主要负责新生代区的垃圾回收。副垃圾回收器采用 Scavenge 算法进行垃圾回收

**Scavenge算法**

+ 将新生代空间对半划分为两个区域，一半是对象区域，一半是空闲区域

  <img src=".\浏览器工作原理-geek\V8新生代堆空间.png" style="zoom:50%;" />

+ 新加入的对象都会存放在对象区域，**当对象区域快被写满时**，就需要**执行一次垃圾清理**操作：

  + 检查对象区域中存活的对象
  + 将存活对象复制到空闲区域，同时会把这些对象有序地排列起来，所以复制后空闲区域就没有内存碎片了
  + 完成复制后，对象区域与空闲区域进行角色翻转。这种角色翻转的操作让新生代中的这两块区域无限重复使用下去

**注意：**

+ 在每次执行清理操作时都需要进行复制操作，如果新生区设置得太大，那么每次清理的时间就会过久，所有为了执行效率，**一般新生区的空间会被设置得比较小**
+ 因为新生区的空间不大，所有很容易被存活的对象装满整个区域。为了解决这个问题，JavaScript引擎采用了对象晋升策略，也就是经过两次垃圾回收依然还存活的对象，会被移动到老生区



###### 主垃圾回收器

> 主垃圾回收器主要负责老生区中的垃圾回收。除了**新生区中晋升的对象，一些大的对象会直接被分配到老生区**。主垃圾回收器将标记-清除（Mark-Sweep）和标记-整理（Mark-Compact）两种算法结合使用
>
> 老生区中的对象的特点：
>
> + 对象占用空间大
> + 对象存活时间长

**标记-清理算法**

+ 从一组根元素（栈中的上下文中的变量）开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素称为**活动对象**，没有到达的元素就可以判断为**垃圾数据（非活动对象）**

+ 标记完成后就是垃圾的清除过程

  <img src=".\浏览器工作原理-geek\V8标记清除过程.png" style="zoom:50%;" />

**标记-整理算法**

在多次执行标记-清理算法后，会产生大量不连续的内存碎片。碎片过多会导致大对象无法分配到足够的连续内存，这时需要对内存进行整理，这个过程称为**标记-整理（Mark-Compact）**

> 标记过程和标记-清除算法中一样，但后续不是直接对非活动对象进行清理，而是将所有活动对象都向一端移动，然后直接清理掉端边界以外的内存

<img src=".\浏览器工作原理-geek\V8标记整理.png" style="zoom:50%;" />

###### 比较

![](.\浏览器工作原理-geek\垃圾回收算法比较.png)

在 Mark-Sweep 和 Mark-Compact 之间，由于 Mark-Compact 需要移动对象，所以它的执行速度不可能很快，所以在取舍上，V8 主要使用 Mark-Sweep，在空间不足以从新生代中晋升过来的对象进行分配时才使用 Mark-Compact 。



#### 全停顿

> 由于JavaScript是运行在主线程之上，一旦执行垃圾回收算法，JavaScript脚本的执行就会暂停下来，待垃圾回收完毕后再恢复脚本执行。这种行为就叫做**全停顿（Stop-The-World）**

<img src=".\浏览器工作原理-geek\全停顿.png" style="zoom:50%;" />

在V8新生代的垃圾回收中，因其空间较小，且存活对象较少，所以全停顿的影响不大，但老生代的垃圾回收对全停顿的影响较大。为了降低老生代的垃圾回收而造成的卡顿，V8将**标记过程分为一个个的子标记过程，同时让垃圾回收标记和JavaScript应用逻辑交替进行，直到标记阶段完成**，这个算法称为**增量标记（Incremental Marking）**算法

<img src=".\浏览器工作原理-geek\增量标记.png" style="zoom: 50%;" />



### 执行JavaScript流程

#### 编译器和解释器

> 因为机器不能直接理解我们所写的代码，所有在执行程序之前，需要将我们所写的代码“翻译”成机器能读懂的机器语言。
>
> 按“翻译”的执行流程，可以把语言分为编译型语言和解释型语言。
>
> + 编译型语言在程序执行之前，需要经过编译器的编译过程，并且编译之后会直接保留机器能读懂的二进制文件，这样每次运行程序时，都可以直接运行该二进制文件，而不需要再次重新编译。
>
> + 解释型语言编写的程序，在每次运行时都需要通过解释器对程序进行动态解释和执行。

<img src=".\浏览器工作原理-geek\编译器和解释器工作流程.png" style="zoom:50%;" />

+ 编译器执行流程

  编译器首先会依次对源代码进行词法分析、语法分析，生成抽象语法树（AST），然后是优化代码，最后再生成**处理器能够理解的机器码**。如果编译成功，将会**生成一个可执行的文件**。但如果编译过程发生了语法或者其他的错误，那么编译器就会抛出异常，最后的二进制文件也不会生成成功。

+ 解释器执行流程

  解释器也会对源代码进行词法分析、语法分析，并生成抽象语法树（AST），不过它会再基于抽象语法树生成字节码，最后再根据字节码来执行程序、输出结果。



#### 执行流程

<img src=".\浏览器工作原理-geek\V8执行代码的流程.png" style="zoom:50%;" />

1. 生成抽象语法树（AST）和执行上下文

   > 对于编译器或者解释器来说，它们很难理解源代码，需要将源代码转换为它们可以理解的数据，即AST，可以将其看成源代码结构化的表示。

   + 词法分析：将源码拆解成一个个token。所谓token，指的是语法上不可能再分的、最小的单个字符或字符串。

   + 语法分析：将词法分析阶段生成的token数据，根据语法规则转为AST。如果源码中存在语法错误，这一步就会终止，并抛出一个“语法错误”。

     当生成AST后，V8就会生成该段代码的执行上下文。

2. 生成字节码

   > 解释器Ignition会根据AST生成字节码，并解释执行字节码

   字节码就是介于AST和机器码之间的一种代码。字节码需要通过解释器将其转换为机器码后才能执行。

   早期V8直接将AST转换为机器码，虽然执行机器码的效率非常高效，但机器码需要消耗大量的内存来存放，这在移动端上会出现非常大的内存占用问题。

   <img src=".\浏览器工作原理-geek\字节码和机器码占用空间对比.png" style="zoom:50%;" />

3. 执行代码

   > 在生成字节码后，解释器Ignition会逐条解释执行。在Ignition执行字节码的过程中，如果发现有热点代码（HotPot，即被重复执行多次的代码），那么后台的编译器TurboFan就会把该段热点字节码编译为高效的机器码，然后当再次执行这段被优化的代码时，只需要执行编译后的机器码就可以，这样就大大提升了代码的执行效率（省去了字节码“翻译”为机器码的过程）。

   这种字节码配合解释器和编译器的技术称为**即时编译（JIT）**。具体到V8，就是指解释器Ignition在解释字节码的同时，收集代码信息，当它发现某一部分代码变热了之后，TurboFan编译器把热点的字节码转换为机器码，并把转换后的机器码保存起来，以备下次使用。

   <img src=".\浏览器工作原理-geek\即时编译技术.png" style="zoom:50%;" />



## JavaScript执行机制

### 执行流程

> JavaScript代码的执行流程大致分为两个阶段：编译阶段和执行阶段

#### 编译阶段

> 经过编译阶段，**一段JavaScript代码**会生成两部分内容：**执行上下文（Execution context）**和**可执行代码**
>
> 以下三种情况，经过编译会生成“这一段代码”的执行上下文：
>
> + 当 JavaScript 执行全局代码的时候，会编译全局代码并创建全局执行上下文，而且在整个页面的生存周期内，全局执行上下文只有一份。
> + 当调用一个函数的时候，函数体内的代码会被编译，并创建函数执行上下文，一般情况下，函数执行结束之后，创建的函数执行上下文会被销毁。
> + 当使用 `eval` 函数的时候，`eval` 的代码也会被编译，并创建执行上下文。

<img src=".\浏览器工作原理-geek\JavaScript执行流程细化图.png" style="zoom:50%;" />

+ 第1行和第2行，由于这两行代码不是声明操作，所以JavaScript引擎不会做任何处理
+ 第3行，由于这行是经过var声明的，因此JavaScript引擎将在环境对象中创建一个名为`myName`的属性，并使用undefined对其初始化
+ 第4行，JavaScript引擎发现了一个通过function定义的函数，所以它将函数定义存储到堆中，并在环境对象中创建一个`showName`的属性，然后将该属性值指向堆中函数的位置

在生成了变量环境对象后，JavaScript引擎会把声明以外的代码编译为字节码

**注意：在编译阶段，如果出现同名的函数，后声明的函数会覆盖前面声明的函数；如果变量和函数同名，变量的说明会被忽略。**

#### 执行阶段

> JavaScript引擎开始按顺序，一行一行地执行“可执行代码”

+ 当执行到`showName`函数时，JavaScript引擎便开始在变量环境对象中查找该函数，由于变量环境对象中存在该函数的引用，所以JavaScript引擎便开始执行该函数，并输出结果
+ 接下来打印“`myName`”信息，JavaScript引擎继续在变量环境对象中查找该对象，由于变量环境存在`myName`变量，并且其值为undefined，所以这时候就输出undefined
+ 接下来执行第3行，把“极客时间”赋值给`myName`变量，赋值后变量环境中的`myName`属性值改变为“极客时间”



### 调用栈

> 一种用来管理执行上下文的栈，也称执行上下文栈

+ 当编译完全局代码，开始执行时，JavaScript引擎将生成的全局执行上下文压入调用栈中，然后JavaScript引擎开始执行全局代码。
+ 每调用一个函数，JavaScript引擎会编译函数体内的代码并为其创建执行上下文，并把该执行上下文压入调用栈，然后JavaScript引擎开始执行函数代码。
+ 如果在一个函数A中调用了另外一个函数B，那么JavaScript引擎会为B函数创建执行上下文，并将B函数的执行上下文压入栈顶
+ 当前函数执行完毕后，JavaScript引擎会将该函数的执行上下文弹出栈。
+ 当分配的调用栈空间被占满时，会引发“栈溢出”问题。



### 作用域

> 作用域是指程序中**定义变量与函数的区域**，该定义位置决定了变量与函数的生命周期。
>
> 通俗地理解，作用域就是变量与函数的可访问范围，即作用域控制着变量和函数的**可见性**和**生命周期**。

在`ES6`之前，ES的作用域只有两种：全局作用域和函数作用域

+ 全局作用域即任何函数之外的区域，全局作用域中定义的变量和函数在代码中的任何地方都能访问，其生命周期伴随着页面的生命周期。
+ 函数作用域即函数体内部的区域，函数内部定义的变量或者函数只能在函数内部被访问。函数执行结束之后，函数内部定义的变量会被销毁。

由于没有块级作用域，JavaScript通过把作用域内部的变量与函数统一提升的方式实现了函数作用域的设计。但变量提升也带来了以下问题：

1. 变量容易在不被察觉的情况下被覆盖掉（代码块内定义的变量覆盖掉了函数作用域或全局作用域中的变量）
2. 本应销毁的变量没有被销毁（代码块中定义的变量在代码块执行完毕后依然存在于函数作用域内）

**ES6块级作用域实现方案**

> ES6引入了let和const关键字，通过它们声明的变量拥有块级作用域

```javascript
function foo(){
    var a = 1
    let b = 2
    {
      let b = 3
      var c = 4
      let d = 5
      console.log(a)
      console.log(b)
    }
    console.log(b) 
    console.log(c)
    console.log(d)
}   
foo()
```

+ 第一步是编译并创建执行上下文
  + 函数内部通过var声明的变量，在编译阶段全部被存放到变量环境中
  + 通过let声明的变量，在编译阶段会被存放到词法环境中
  + 在函数的作用域块内部，通过let声明的变量并没有被存放到词法环境中

<img src=".\浏览器工作原理-geek\foo函数的执行上下文.png" style="zoom:50%;" />

+ 第二步继续执行代码，当执行到代码块里面时，变量环境中a的值已经被设置成了1，词法环境中b的值已经被设置成了2。

  当进入函数的作用域块时，作用域块中通过let声明的变量，会被存放在词法环境的一个单独的区域中。

  **在词法环境内部，维护了一个小型栈结构，栈底是函数最外层的变量，进入一个作用域块后，就会把该作用域块内部的变量压到栈顶；当作用域执行完成之后，该作用域的信息就会从栈顶弹出，这就是词法环境的结构**。

<img src="D:.\浏览器工作原理-geek\执行foo函数内部作用域块时的执行上下文.png" style="zoom:50%;" />

+ 当执行到作用域块中的console.log(a)这行代码时，就需要在词法环境和变量环境中查找变量a的值。具体查找规则如下：

  **沿着词法环境的栈顶向下查询，如果在词法环境中的某个块中查找到了，就直接返回到JavaScript引擎，如果没有查找到，那么继续在变量环境中查找**。

  <img src=".\浏览器工作原理-geek\变量查找过程.png" style="zoom:50%;" />

+ 当作用域块执行结束之后，其内部定义的变量就会从词法环境的栈顶弹出

  <img src=".\浏览器工作原理-geek\块作用域执行完成.png" style="zoom:50%;" />

#### 作用域链

> 链接了**各级词法作用域**所对应的**执行上下文**的链条，规定了各级作用域中标识符的解析规则。（作用域链由词法作用域决定，即源代码结构确定）
>
> 每个执行上下文的变量环境中，都包含一个外部引用，用来指向外部的执行上下文，我们把这个外部引用称为outer。

##### 词法作用域

> 词法作用域就是指作用域是在编译阶段确定的，由源代码中函数**声明**的位置来决定

##### 标识符解析规则

> 当前执行上下文的词法环境—>当前执行上下文的变量环境—>当前执行上下文变量环境中outer指向的执行上下文

<img src=".\浏览器工作原理-geek\变量查找规则.png" style="zoom:50%;" />

#### 闭包

> 闭包就是绑定了作用域链的函数。这个作用域链是在函数定义的时候就确定了，与函数在哪执行无关。它可以使外部函数作用域中的变量在函数执行完后依然保存在内存中，通过作用域链来访问。

```javascript
function foo() {
    var myName = "极客时间"
    let test1 = 1
    const test2 = 2
    var innerBar = {
        getName:function(){
            console.log(test1)
            return myName
        },
        setName:function(newName){
            myName = newName
        }
    }
    return innerBar
}
var bar = foo()
bar.setName("极客邦")
bar.getName()
console.log(bar.getName())
```

`foo` 函数执行完成之后，其执行上下文从栈顶弹出了，但是由于返回的 `setName` 和 `getName` 方法中使用了` foo `函数内部的变量 `myName` 和 `test1`，所以这两个变量依然保存在内存中

<img src=".\浏览器工作原理-geek\闭包的产生.png" style="zoom:50%;" />



## 页面的事件循环系统

> 浏览器中的每个渲染进程都有一个主线程，主线程既要执行**渲染任务**，同时还要处理**JavaScript任务**以及**各种输入事件**。要让这么多**不同类型的任务**在主线程中**有条不紊地执行**，需要一个系统来统筹调度这些任务，这个统筹调度系统就是**事件循环系统**。 
>
> **注**：JavaScript 本身并没有事件循环机制，我们一般所说的 JavaScript 的 Event Loop，准确来说应该是宿主环境（如浏览器）的事件循环中与 JavaScript 交互的部分。

<img src=".\浏览器工作原理-geek\事件循环.png" style="zoom:50%;" />

### 消息队列

> 用于存放主线程将要执行的任务，实现了线程之间的消息通信。

### 消息队列中的任务类型

#### 宏任务

> 由宿主环境发起的任务

**缺点：**

+ 时间粒度较大，执行的时间间隔不能精确控制

> 页面的渲染事件、各种 IO 的完成事件、执行 JavaScript 脚本的事件、用户交互的事件等都随时有可能被添加到消息队列中，而且添加事件是由系统操作的，JavaScript 代码不能准确掌控任务要添加到队列中的位置，控制不了任务在消息队列中的位置，所以很难控制开始执行任务的时间

#### 微任务

> 微任务就是一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前。

**优点：**

+ 时间粒度小，在一定程度上保证了任务执行的实时性
+ 通过异步执行，解决了同步操作的性能问题

##### 微任务产生的时机

+ 使用 MutationObserver 监控某个 DOM 节点，当 DOM 节点发生变化时，就会产生 DOM 变化记录的微任务
+ 使用Promise，当Promise的状态resolved或者rejected时，就会产生Promise状态变化处理程序的微任务

##### 执行微任务队列的时机

> 在当前宏任务中的 JavaScript 快执行完成时，也就在 JavaScript 引擎准备退出全局执行上下文并清空调用栈的时候，JavaScript 引擎会检查全局执行上下文中的微任务队列，然后按照顺序执行队列中的微任务。
>
> 执行微任务的过程中，如果产生了新的微任务，该微任务会被添加到微任务队列中，V8 引擎一直循环执行微任务队列中的任务，直到队列为空才算执行结束。也就是说在执行微任务过程中产生的新的微任务并不会推迟到下个宏任务中执行，而是在当前的宏任务中继续执行。

#### 宏任务与微任务之间的关联

+ 微任务和宏任务时绑定的，每个宏任务在执行时，会创建自己的微任务队列
+ 微任务的执行时长会影响到当前宏任务的执行时长。
+ 在一个宏任务中创建的宏任务和微任务，无论什么情况下，微任务都先于宏任务执行

### XMLHttpRequest运行机制

#### 回调函数

> 将一个函数作为参数传递给另外一个函数，那么这个作为参数的函数称为回调函数。
>
> 回调类型
>
> + 同步回调：回调函数在主函数内部执行
> + 异步回调：回调函数在主函数外部执行

<img src=".\浏览器工作原理-geek\XMLHttpRequest工作流程.png" style="zoom:50%;" />

### Promise

+ Promise 中为什么要引入微任务？



+ Promise 中是如何实现回调函数返回值穿透的？



+ Promise 出错后，是怎么通过“冒泡”传递给最后那个捕获异常的函数？





## 页面渲染

### DOM

> 用于表述HTML文档的内部数据结构

在渲染引擎中，DOM有三个层面的作用：

+ 从页面的视角来看，DOM 是生成页面的基础数据结构。
+ 从 JavaScript 脚本视角来看，DOM 提供给 JavaScript 脚本操作的接口，通过这套接口，JavaScript 可以对 DOM 结构进行访问，从而改变文档的结构、样式和内容。
+ 从安全视角来看，DOM 是一道安全防护线，一些不安全的内容在 DOM 解析阶段就被拒之门外了。

#### DOM的生成过程

> 当网络进程在收到响应头数据后将其传递给浏览器进程，浏览器进程会根据响应头中的`content-type`字段来判断响应数据的类型，若为`text/html`，那么浏览器会创建一个渲染进程。当渲染进程创建好后，**渲染进程和网络进程之间会建立一个共享数据的管道**，网络进程在接收到数据后就往这个管道里面放，而渲染进程会在管道的另一端不断地读取数据，并把数据“喂”给HTML解析器。

##### HTML解析器工作原理

> `html`字节流 —> Token —>（节点Node—>DOM树）

HTML 解析器维护了一个 **Token 栈结构**，该 Token 栈主要用来计算节点之间的父子关系，在第一个阶段中生成的 Token 会被按照顺序压到这个栈中。具体的处理规则如下所示：

+ 如果压入到栈中的是 StartTag Token，HTML 解析器会为该 Token 创建一个 DOM 节点，然后将该节点加入到 DOM 树中，它的父节点就是栈中相邻的那个元素生成的节点。
+ 如果分词器解析出来是文本 Token，那么会生成一个文本节点，然后将该节点加入到 DOM 树中，文本 Token 是不需要压入到栈中，它的父节点就是当前栈顶 Token 所对应的 DOM 节点。
+ 如果分词器解析出来的是 EndTag 标签，比如是 EndTag div，HTML 解析器会查看 Token 栈顶的元素是否是 StarTag div，如果是，就将 StartTag div 从栈中弹出，表示该 div 元素解析完成。

通过分词器产生的新 Token 就这样不停地压栈和出栈，整个解析过程就这样一直持续下去，直到分词器将所有字节流分词完成。

### 首屏显示

从输入URL到首次显示页面内容，在视觉上会经历三个阶段：

+ 第一个阶段，等请求发出去之后，到提交数据阶段，这时**页面展示出来的还是之前页面的内容**。
+ 第二个阶段，**提交数据完成后渲染进程会创建一个空白页面**，我们通常把这段时间称为**解析白屏（当前处于解析HTML数据阶段）**，并等待 CSS 文件和 JavaScript 文件的加载完成，生成 `CSSOM` 和 `DOM`，然后合成布局树，最后还要经过一系列的步骤完成首次渲染。
+ 第三个阶段，等**首次渲染完成（位图生成完成）之后**，就开始进入**完整页面的生成阶段**了，然后页面会一点点被绘制出来。

<img src=".\浏览器工作原理-geek\含有JavaScript文件和css文件页面的渲染流水线.png" style="zoom:50%;" />

### 页面更新

#### 图像显示原理

> 显示器按照**固定的速率**（屏幕刷新率）从显卡的**前缓冲区**读取图像，并将读取到的图像显示到显示器上。
>
> 显卡的职责就是合成新的图像，并将图像保存到**后缓冲区**中，一旦显卡把合成的图像写到后缓冲区，系统就会让后缓冲区和前缓冲区互换，以保证显示器能读取到最新显卡合成的图像。

**帧和帧率**

> 在浏览器中，把渲染流水线生成的每一副图片称为一**帧**，把渲染流水线每秒更新了多少帧称为**帧率**。

**实现流畅动画的条件**

> 屏幕刷新率 = 显卡更新频率（渲染引擎生成图像的帧率）

#### 生成图像的方式

> 生成图像，即触发渲染引擎工作，生成一副图像。

+ 重排

  > 渲染流水线的每个阶段都会执行一遍

+ 重绘

  > 触发渲染流水线中绘制操作之后的一系列操作

+ 合成

  > 没有布局和绘制操作，只有在合成线程上进行的阶段会被触发

#### 合成

> Chrome中的合成技术，可以概括为：分层、分块和合成。

**分层**

> 如果从布局树直接生成目标图片，那么每次页面有很小的变化时，都会触发重排重绘机制，这种“牵一发而动全身”的绘制策略会严重影响页面的渲染效率。

在生成布局树后，渲染引擎会根据布局树的特点将其转换为分层树（Layer Tree），层树是渲染流水线后续流程的基础结构。

层树中的每一个节点都对应着一个图层，这样，页面被分成多个图层，**每一个图层都对应一张图片**。

**分块**

> 通常情况下，页面的内容会超出视口的范围，显示一个页面时，如果等待所有的图层都生成完毕再合成的话，会产生一些不必要的开销，也会让合成图片的时间变得更久。
>
> 因此，合成线程将每个图层分割为大小固定的图块，然后优先绘制靠近视口的图块，这样就可以大大加速页面的显示速度。

**合成**

> 光栅化阶段会根据绘制阶段生成的绘制指令列表生成图片，每一个图层对应一张图片，合成线程有了这些图片后，会将这些图片合成“一张”图片，并最终将这张图片发送到**后缓冲区**



### 页面优化

> 页面优化即让页面更快的显示和响应

通常一个页面的生命周期有三个阶段：加载阶段、交互阶段和关闭阶段。

+ 加载阶段，是指从**发出请求到渲染出完整页面**的过程，影响到这个阶段的主要因素有**网络**和 **JavaScript 脚本**。
+ 交互阶段，主要是**从页面加载完成到页面关闭**之间的整个过程，影响到这个阶段的主要因素是 **JavaScript 脚本**。
+ 关闭阶段，主要是用户发出关闭指令后页面所做的一些清理操作。

#### 加载阶段

> 加载阶段的优化目标是提升**首屏渲染完成速度**

加载阶段渲染流水线

<img src=".\浏览器工作原理-geek\加载阶段渲染流水线.jpg" style="zoom:50%;" />

影响页面首次渲染的核心因素主要有三个

+ 关键资源个数（能够阻塞页面首次渲染的资源称为关键资源）

  > 关键资源个数越多，首次页面的加载时间就越长

+ 关键资源的大小

  > 通常情况下，所有关键资源的内容越小，其整个资源的下载时间也就越短，那么阻塞渲染的时间也就越短

+ 请求关键资源需要多少个`RTT`（Round Trip Time）

  > `RTT`是网络中一个重要的性能指标，表示从发送端发送数据开始，到发送端收到来自接收端的确认，总共经历的时延

优化手段：

+ 关键资源个数
  + 将JavaScript和css改成内联的形式，这样它们就不算关键资源
  + 如果JavaScript代码没有DOM或者CSSOM的操作，则可以添加async或者defer属性
+ 关键资源的大小
  + 压缩css和JavaScript资源，移除HTML、CSS、JavaScript文件中一些注释内容
+ 减少关键资源RTT的次数
  + 减少关键资源个数和大小
  + 使用CDN加载关键资源

#### 交互阶段

> 交互阶段的优化目标是提升**渲染进程渲染帧的速度**，即加快单个帧的生成速度

交互阶段的渲染流水线

<img src=".\浏览器工作原理-geek\交互阶段渲染流水线.png" style="zoom:50%;" />

大部分情况下，交互阶段生成一个新的帧都是由JavaScript通过修改DOM或者CSSOM来触发的，还有一部分帧是由CSS来触发的。

优化手段：

+ 减少JavaScript脚本执行时间

  > JavaScript代码执行过久会导致占用主线程过久，霸占了渲染任务的执行时间

  + 将一些与DOM操作无关且耗时的任务放到Web Workers中去执行

+ 避免强制同步布局？？？？？

  > 所谓强制同步布局，是指JavaScript强制将计算样式和布局操作提前到当前的任务中

  正常情况下，通过DOM接口改变页面结构和元素样式后，是需要重新计算样式和布局的，为了避免当前的任务占用太长的主线程时间，计算样式和布局的操作会在**另外的任务中异步完成**。但如果在修改DOM结构时去访问一些特殊的元素属性，则计算样式和布局的操作会在当前任务中立即执行

+ 避免布局抖动

  > 在一次JavaScript执行过程中，多次执行强制布局和抖动操作

+ 合理利用CSS合成动画

  > 合成动画直接在合成线程上执行，即使主线程被JavaScript或者一些布局任务占用，CSS动画依然能继续执行

+ 避免频繁的垃圾回收

  > 如果在一些函数中频繁的创建临时对象，那么垃圾回收器也会频繁地去执行垃圾回收策略。
  >
  > 当垃圾回收操作发送时，就会**占用主线程**，从而影响到其他任务的执行，**影响到一帧的生成时长**



### 虚拟DOM

> 一种类似于DOM的技术，被应用于前端框架中，用来提高应用的性能。

#### 背景

> 操作DOM会触发渲染引擎进行重排、重绘或者合成等操作，对于复杂的页面，执行一次重排或者重绘操作都是非常耗时的，这会带来性能问题。
>
> 因此，需要尽可能的减少JavaScript对DOM的操作，这时候虚拟DOM便可派上用场。

#### 什么是虚拟DOM

+ 用于描述视图的数据结构

+ DOM的一个buffer

  > 虚拟DOM可以先将视图的变化保存起来，然后一次性的更新到DOM上去。

+ 充当MVC模式中的View

#### 运行方式

+ 创建阶段。首先依据 JSX 和基础数据创建出来虚拟 DOM，它反映了真实的 DOM 树的结构。然后由虚拟 DOM 树创建出真实 DOM 树，真实的 DOM 树生成完后，再触发渲染流水线往屏幕输出页面。
+ 更新阶段。如果数据发生了改变，那么就需要根据新的数据创建一个新的虚拟 DOM 树；然后 React 比较两个树，找出变化的地方，并把变化的地方一次性更新到真实的 DOM 树上；最后渲染引擎更新渲染流水线，并生成新的页面。

#### 解决的问题

+ 频繁更新DOM而引发的性能问题
+ 降低了操作DOM的难度





## 网络

> HTTP是浏览器中最重要且使用最多的协议，是浏览器和服务器之间的通信语言。

### HTTP请求流程

<img src=".\浏览器工作原理-geek\HTTP请求流程.png" style="zoom:50%;" />

### HTTP/1

#### HTTP 0.9

<img src=".\浏览器工作原理-geek\HTTP0.9请求流程.png" style="zoom:50%;" />

**诞生背景**

> Web主要被用于学术交流，网络之间传递的只是简单的HTML文件

**解决问题**

> 实现了HTML文件的传输

**特点**

+ 请求信息只有请求行，响应信息只有数据

#### HTTP 1.0

<img src=".\浏览器工作原理-geek\HTTP1.0请求流程.png" style="zoom:50%;" />

**诞生背景**

> web进入了高速发展阶段，不再局限于学术交流，需要在网络之间传输多种类型的文件

**解决问题**

> 支持多种类型文件下载

**特点**

+ 在通信报文中通过增加**请求头**和**响应头**来支持多种不同类型的数据。

  > 浏览器通过请求头告诉服务器它期待服务器返回什么类型的文件、采取什么形式压缩、提供什么语言的文件以及文件的具体编码等信息；
  >
  > 服务器通过响应头告诉浏览器最终返回的数据的相关信息

+ 引入了状态码。通过状态码告诉浏览器服务器最终处理该请求的情况

+ 提供了Cache机制，用来缓存已经下载过的数据

+ 在请求头中引入了用户代理字段

#### HTTP 1.1

> HTTP/1.1是针对HTTP/1.0的一些不足，在其基础上的改进版本

**改进措施**

1. 改进持久连接

   > HTTP/1.0每进行一次HTTP通信，都需要经历建立TCP连接、传输HTTP数据和断开TCP连接三个阶段。当一个页面中的外部引用资源文件很多时，这将会增加大量无谓的开销。
   >
   > HTTP/1.1默认开启持久连接，即在一个TCP连接上可传输多个HTTP请求，只要浏览器或者服务器没有明确断开连接，那么该TCP连接会一直保持。（浏览器为每个域名最多同时维护6个TCP持久连接）

2. 不成熟的HTTP管线化

   > HTTP/1.0中只有在当前请求返回之后，才能进行下一次请求。如果TCP通道中的某个请求没有完成，那么就会阻塞后面的所有请求（队头阻塞）。
   >
   > 所谓管线化，是指多个HTTP请求可以整批提交给服务器，但服务器必须根据请求的顺序来回复浏览器的请求（**依然没有解决队头阻塞**）。

3. 提供虚拟主机的支持

   > 同一台物理主机上可以绑定多个虚拟 主机，每个虚拟主机都有自己的单独的域名，这些单独的域名都公用同一个IP地址。
   >
   > HTTP/1.1的请求头中增加了`Host`字段，用来表示当前的域名地址，这样服务器就可以根据不同的`Host`值做不同的处理。

4. 对动态生成的内容提供了完美支持

   > 当服务端响应的内容为动态生成时，在传输数据之前并不知道数据的大小，无法通过`Content-Length`字段告诉浏览器响应文件的大小，浏览器不知道何时会接收完所有文件数据。
   >
   > HTTP/1.1通过引入`Chunk transfer` 机制来解决这个问题，服务器会将数据分割成若干个任意大小的数据块，每个数据块发送时会附上数据块的长度，最后使用一个零长度的块作为发送数据完成的标志。

5. 客户端Cookie、安全机制



### HTTP/2

**HTTP/1.1的主要问题**

> 对带宽的利用率比较低

主要原因如下：

+ TCP的慢启动

  > 一旦一个 TCP 连接建立之后，就进入了发送数据状态，刚开始 TCP 协议会采用一个非常慢的速度去发送数据，然后慢慢加快发送数据的速度，直到发送数据的速度达到一个理想状态，我们把这个过程称为慢启动。
  >
  > 这会增加首次渲染页面的时间

+ 同时开启了多条TCP连接，那么这些连接会竞争固定的带宽

  > 系统同时建立了多条TCP连接后，当带宽不足时，这些TCP连接会减慢发送或者接收的速度。
  >
  > 这些TCP连接中，有的TCP连接下载的是关键资源，有的TCP连接下载的是普通的资源，但TCP连接之间又不能协商优先级，因此这可能会影响那些关键资源的下载速度。

+ HTTTP/1.1队头阻塞的问题（HTTP层面）

  > 一个TCP连接中同一时刻只能处理一个请求，在当前请求没有结束之前，其他的请求只能处于阻塞状态。
  >
  > 这意味着我们不能在一个管道中发送请求和接收内容

**注意：慢启动和TCP连接之间相互竞争带宽是由于TCP本身的机制导致的，而队头阻塞是由于HTTP/1.1的机制导致的**

#### HTTP/2的多路复用

> 在一个TCP连接上可以同时进行多个请求-响应，而不必按序进行。

HTTP/2针对HTTP/1.1的问题的解决方案为：一个域名只使用一个TCP长连接（慢启动和连接竞争）和消除队头阻塞问题

<img src=".\浏览器工作原理-geek\HTTP2的多路复用.jpg" style="zoom:50%;" />

#### 多路复用的实现 

<img src=".\浏览器工作原理-geek\HTTP2协议栈.png" style="zoom:50%;" />

HTTP/2的请求和接收过程：

+ 首先，浏览器准备好请求数据，包括了请求行、请求头等信息，如果是 POST 方法，那么还要有请求体。
+ 这些数据经过二进制分帧层处理之后，会被转换为一个个带有请求 ID 编号的帧，通过协议栈将这些帧发送给服务器。
+ 服务器接收到所有帧之后，会将所有相同 ID 的帧合并为一条完整的请求信息。
+ 然后服务器处理该条请求，并将处理的响应行、响应头和响应体分别发送至二进制分帧层。
+ 同样，二进制分帧层会将这些响应数据转换为一个个带有请求 ID 编号的帧，经过协议栈发送给浏览器。
+ 浏览器接收到响应帧之后，会根据 ID 编号将帧的数据提交给对应的请求。

通过引入二进制分帧层，实现了HTTP的多路复用技术。

#### HTTP/2其他特性

+ 可以设置请求的优先级
+ 服务器推送
+ 头部压缩



### HTTP/3

#### HTTP/2的缺陷

+ TCP的队头阻塞（数据包层面）

  > 在数据传输过程中，有一个数据因为网络故障或者其他原因而丢包了，那么整个TCP的连接中的所有请求就会处于暂停状态，需要等待丢失的数据包被重新传输过来

  <img src=".\浏览器工作原理-geek\TCP丢包状态.png" style="zoom:50%;" />

+ TCP建立连接的延时

  > 在建立TCP连接的时候，需要和服务器进行三次握手来确认连接成功，也就说需要在消耗完1.5个RTT之后才能进行数据传输
  >
  > 进行TLS连接，TLS有两个版本——TLS1.2和TLS1.3，每个版本建立连接所花的时间不同，大致是需要1~2个RTT

+ TCP协议僵化

  > TCP协议实现于各种中间设备和操作系统中，通过优化TCP协议来解决缺陷将非常困难

#### QUIC协议

> 因为中间设备的僵化，这些设备只认 TCP 和 UDP，如果采用了新的协议，新协议在这些设备同样不被很好地支持。因此，HTTP/3 选择了一个折衷的方法——UDP 协议，基于 UDP 实现了类似于 TCP 的多路数据流、传输可靠性等功能，我们把这套功能称为 QUIC （*Quic*k UDP Internet Connection）协议。

<img src=".\浏览器工作原理-geek\HTTP2和HTTP3协议栈.png" style="zoom:50%;" />

QUIC协议集合了以下几点功能：

+ 实现了类似TCP的流量控制、传输可靠性的功能

+ 集成了TLS加密功能

+ 实现了HTTP/2中的多路复用功能。和TCP不同，QUIC实现了同一物理连接上可以有**多个独立的逻辑数据流**。**实现了数据流的单独传输，就解决了TCP中队头阻塞的问题**。

  <img src=".\浏览器工作原理-geek\QUIC协议的多路复用.png" style="zoom:50%;" />

+ 实现了快速握手功能



#### HTTP/3的挑战

在技术层面上，HTTP/3是个完美的协议，不过要将HTTP/3应用到实际环境中依然面临着诸多严峻的挑战，主要来自以下三个方面：

+ 服务器和浏览器端都没有对HTTP/3提供完整的支持
+ 部署困难。因为系统内核对UDP的优化远远没有达到TCP的优化程度。
+ 中间设备僵化。这些设备对UDP的优化程度远远低于TCP



### 缓存

> 浏览器根据第一次请求资源时返回的**响应**头来确定是否缓存资源。
>
> 强缓存：响应头中有以下两个字段
>
> - Expires：HTTP/1.0中定义缓存的字段，它规定了缓存过期的一个绝对时间
> - Cache-control：max-age=231455；HTTP/1.1定义的关于缓存的字段，它规定了缓存过期的一个相对时间
>
> 优先级：max-age > Expires
>
> 启发式缓存：响应头中没有浏览器用来确定过期时间的字段
>
> - 根据响应头中2个时间字段Date和Last-Modified之间的时间差值，取其值的10%作为缓存时间周期

<img src=".\浏览器工作原理-geek\浏览器缓存策略.png" style="zoom: 67%;" />

**与缓存相关的首部字段：**

**1. 通用首部字段**

| 字段名称      | 说明                                                |
| ------------- | --------------------------------------------------- |
| Cache-Control | 控制缓存具体的行为                                  |
| Pragma        | HTTP1.0时的遗留字段，当值为"no-cache"时强制验证缓存 |
| Date          | 创建报文的日期时间(启发式缓存阶段会用到这个字段)    |

**2. 响应首部字段**

| 字段名称 | 说明                                                      |
| -------- | --------------------------------------------------------- |
| ETag     | 服务器生成资源的唯一标识                                  |
| Vary     | 代理服务器缓存的管理信息                                  |
| Age      | 资源在缓存代理中存贮的时长(取决于max-age和s-maxage的大小) |

**3. 请求首部字段**

| 字段名称            | 说明                                                         |
| ------------------- | ------------------------------------------------------------ |
| If-Match            | 条件请求，携带上一次请求中资源的ETag，服务器根据这个字段判断文件是否有新的修改 |
| If-None-Match       | 和If-Match作用相反，服务器根据这个字段判断文件是否有新的修改 |
| If-Modified-Since   | 比较资源前后两次访问最后的修改时间是否一致                   |
| If-Unmodified-Since | 比较资源前后两次访问最后的修改时间是否一致                   |

**4. 实体首部字段**

| 字段名称      | 说明                             |
| ------------- | -------------------------------- |
| Expires       | 告知客户端资源缓存失效的绝对时间 |
| Last-Modified | 资源最后一次修改的时间           |



## 安全

> 浏览器安全可以分为三大块——Web 页面安全、网络安全和系统安全

### Web页面安全

> 浏览器在站点安全上采取的策略

#### 同源策略

> 两个不同的源之间若想要相互访问资源或者操作 DOM，那么会有一套基础的安全策略的制约。
>
> 同源：如果两个 URL 的协议、域名和端口都相同，我们就称这两个 URL 同源

同源策略主要表现在 DOM、Web 数据和网络这三个层面

+ DOM层面

  > 同源策略限制了来自不同源的JavaScript脚本对当前DOM对象读和写的操作

+ Web数据

  > 同源策略限制了不同源的站点读取当前站点的Cookie、IndexDB、LocalStorage等数据

+ 网络

  > 同源政策规定，AJAX请求只能发给同源的网址，否则就报错。

浏览器的安全策略实现了web页面的安全性，不过也在一定程度上使得web项目难以开发和利用，为了在安全性和便利性之间实现平衡，浏览器制定了跨域操作的规则：

+ DOM

+ Web数据

+ 网络

  ##### CORS

  > **跨域资源共享**定义了浏览器和服务器如何实现跨源通信。CORS背后的基本思路就是**使用自定义的HTTP头部允许浏览器和服务器相互了解，以确实请求或响应应该成功还是失败**

  **简介**

  CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。

  整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。

  因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。

  **两种请求**

  浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。

  只要同时满足以下两大条件，就属于简单请求。

  ```markdown
  （1) 请求方法是以下三种方法之一：
  - HEAD
  - GET
  - POST
  
  （2）HTTP的头信息不超出以下几种字段：
  - Accept
  - Accept-Language
  - Content-Language
  - Content-Type：只限于三个值`application/x-www-form-urlencoded`、`multipart/form-data`、`text/plain`
  - DPR
  - Downlink
  - Save-Data
  - Viewport-Width
  - Width
  ```

  凡是不同时满足上面两个条件，就属于非简单请求。

  **简单请求**

  对于**简单请求**，浏览器**直接发出CORS请求**。具体来说，就是在头信息之中，**增加一个`Origin`字段**。

  下面是一个例子，浏览器发现这次跨源AJAX请求是简单请求，就自动在头信息之中，添加一个`Origin`字段。

  > ```http
  > GET /cors HTTP/1.1
  > Origin: http://api.bob.com
  > Host: api.alice.com
  > Accept-Language: en-US
  > Connection: keep-alive
  > User-Agent: Mozilla/5.0...
  > ```

  上面的头信息中，`Origin`字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。

  如果`Origin`指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含`Access-Control-Allow-Origin`字段（详见下文），就知道出错了，从而抛出一个错误，被`XMLHttpRequest`的`onerror`回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。

  如果`Origin`指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。

  > ```http
  > Access-Control-Allow-Origin: http://api.bob.com
  > Access-Control-Allow-Credentials: true
  > Access-Control-Expose-Headers: FooBar
  > Content-Type: text/html; charset=utf-8
  > ```

  上面的头信息之中，有三个与CORS请求相关的字段，都以`Access-Control-`开头。

  **非简单请求**

  非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为"预检"请求（preflight）。

  浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的`XMLHttpRequest`请求，否则就报错。

  下面是一段浏览器的JavaScript脚本。

  > ```javascript
  > var url = 'http://api.alice.com/cors';
  > var xhr = new XMLHttpRequest();
  > xhr.open('PUT', url, true);
  > xhr.setRequestHeader('X-Custom-Header', 'value');
  > xhr.send();
  > ```

  上面代码中，HTTP请求的方法是`PUT`，并且发送一个自定义头信息`X-Custom-Header`。

  浏览器发现，这是一个非简单请求，就自动发出一个"预检"请求，要求服务器确认可以这样请求。下面是这个"预检"请求的HTTP头信息。

  > ```http
  > OPTIONS /cors HTTP/1.1
  > Origin: http://api.bob.com
  > Access-Control-Request-Method: PUT
  > Access-Control-Request-Headers: X-Custom-Header
  > Host: api.alice.com
  > Accept-Language: en-US
  > Connection: keep-alive
  > User-Agent: Mozilla/5.0...
  > ```

  "预检"请求用的请求方法是`OPTIONS`，表示这个请求是用来询问的。头信息里面，关键字段是`Origin`，表示请求来自哪个源。

  除了`Origin`字段，"预检"请求的头信息包括两个特殊字段。

  **（1）Access-Control-Request-Method**

  该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是`PUT`。

  **（2）Access-Control-Request-Headers**

  该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是`X-Custom-Header`。

  **预检请求的回应**

  服务器收到"预检"请求以后，检查了`Origin`、`Access-Control-Request-Method`和`Access-Control-Request-Headers`字段以后，确认允许跨源请求，就可以做出回应。

  > ```http
  > HTTP/1.1 200 OK
  > Date: Mon, 01 Dec 2008 01:15:39 GMT
  > Server: Apache/2.0.61 (Unix)
  > Access-Control-Allow-Origin: http://api.bob.com
  > Access-Control-Allow-Methods: GET, POST, PUT
  > Access-Control-Allow-Headers: X-Custom-Header
  > Content-Type: text/html; charset=utf-8
  > Content-Encoding: gzip
  > Content-Length: 0
  > Keep-Alive: timeout=2, max=100
  > Connection: Keep-Alive
  > Content-Type: text/plain
  > ```

  上面的HTTP回应中，关键的是`Access-Control-Allow-Origin`字段，表示`http://api.bob.com`可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。

  > ```http
  > Access-Control-Allow-Origin: *
  > ```

  如果服务器否定了"预检"请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被`XMLHttpRequest`对象的`onerror`回调函数捕获。

  **浏览器的正常请求和回应**

  一旦服务器通过了"预检"请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个`Origin`头信息字段。服务器的回应，也都会有一个`Access-Control-Allow-Origin`头信息字段。

  下面是"预检"请求之后，浏览器的正常CORS请求。

  > ```http
  > PUT /cors HTTP/1.1
  > Origin: http://api.bob.com
  > Host: api.alice.com
  > X-Custom-Header: value
  > Accept-Language: en-US
  > Connection: keep-alive
  > User-Agent: Mozilla/5.0...
  > ```

  上面头信息的`Origin`字段是浏览器自动添加的。

  下面是服务器正常的回应。

  > ```http
  > Access-Control-Allow-Origin: http://api.bob.com
  > Content-Type: text/html; charset=utf-8
  > ```

  上面头信息中，`Access-Control-Allow-Origin`字段是每次回应都必定包含的。



#### XSS

> XSS 攻击就是黑客往页面中注入恶意脚本，然后将页面的一些重要数据上传到恶意服务器

XSS常见恶意行为：

+ 窃取Cookie信息。通过“document.cookie”获取cookie信息，然后发送给恶意服务器
+ 监听用户行为。使用“addEventListener”接口监听用户行为
+ 修改DOM伪造虚假的登录窗口，用来欺骗用户输入用户名和密码等信息
+ 在页面内生成浮窗广告，严重影响用户体验

根据脚本**注入方式**的不同，可将XSS攻击分为**存储型**XSS攻击、**反射型**XSS攻击和基于**DOM**的XSS攻击。

##### 存储型XSS攻击

<img src=".\浏览器工作原理-geek\存储型XSS攻击.png" style="zoom:50%;" />

存储型XSS攻击的一般步骤：

1. 攻击者将恶意代码提交到目标网站的数据库中。
2. 用户打开目标网站时，**网站服务端将恶意代码从数据库取出**，**拼接在 HTML 中返回给浏览器**。
3. **用户浏览器接收到响应后解析执行**，混在其中的恶意代码也被执行。
4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

这种攻击常见于带有**用户保存数据**的网站功能，如论坛发帖、商品评论、用户私信等



##### 反射型XSS攻击

> 恶意 JavaScript 脚本属于**用户发送给网站请求中的一部分**，随后网站又把**恶意 JavaScript 脚本返回**给用户

反射型XSS攻击的一般步骤：

1. 攻击者构造出特殊的 URL，其中包含恶意代码。
2. 用户打开带有恶意代码的 URL 时，**网站服务端将恶意代码从 URL 中取出**，**拼接在 HTML 中返回给浏览器**。
3. **用户浏览器接收到响应后解析执行**，混在其中的恶意代码也被执行。
4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

反射型 XSS 跟存储型 XSS 的区别是：**存储型** XSS 的**恶意代码存在数据库里**，**反射型** XSS 的**恶意代码存在 URL 里**。

反射型 XSS 漏洞常见于通过 **URL 传递参数**的功能，如网站搜索、跳转等。



##### DOM型XSS攻击

> 一种基于DOM，不涉及Web服务器的XSS攻击

DOM 型 XSS 攻击的一般步骤：

1. 攻击者**构造出特殊的 URL，其中包含恶意代码**。
2. 用户**打开带有恶意代码的 URL**。URL中的恶意代码不会随之发送到服务器，可以躲避服务器的检测。
3. 用户浏览器接收到响应后解析执行，**前端 JavaScript 取出 URL 中的恶意代码并执行**。
4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

DOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，**取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞**，而其他两种 XSS 都属于服务端的安全漏洞。



##### 防范XSS攻击

> 各种类型的XSS攻击，都有一个共同点，那就是首先往浏览器中注入恶意脚本，然后通过恶意脚本将用户信息发送至恶意服务器。
>
> 所有，要阻止XSS攻击，一是**阻止恶意JavaScript脚本的注入**，而是**阻止恶意消息的发送**。

常用阻止XSS攻击策略：

1. 服务器对输入脚本进行过滤或转码
2. 充分利用CSP
3. 使用HttpOnly属性的Cookie
4. 避免将不可信的数据作为HTML插入页面



#### CSRF

> Cross-site request forgery，所以又称为“跨站请求伪造”。
>
> CSRF 攻击就是黑客利用了用户的登录状态，并通过第三方的站点来做一些坏事

**和 XSS 不同的是，CSRF 攻击不需要将恶意代码注入用户的页面，仅仅是利用服务器的漏洞和用户的登录状态来实施攻击**

##### 防范CSRF攻击

发起CSRF攻击的三个必要条件：

+ 第一个，目标站点一定要有CSRF漏洞
+ 第二个，用户要登录过目标站点，并且在浏览器上保持有该站点的登录状态
+ 第三个，需要用户打开一个第三方站点

防范CSRF攻击的主要手段是**提升服务器的安全性**，通常有以下几种途径：

1. 充分利用好Cookie的SameSite属性

2. 验证请求的来源站点（利用Referer（包含路径信息）或Origin（不包含路径信息）字段验证请求来源的站点）

3. 添加Token验证

   工作流程：

   第一步，在浏览器向服务器发起请求时，服务器生成一个 CSRF Token。CSRF Token 其实就是服务器生成的字符串，然后将该字符串植入到返回的页面中。

   第二步，在浏览器端如果要发起相关的请求，那么需要带上页面中的 CSRF Token，然后服务器会验证该 Token 是否合法。如果是从第三方站点发出的请求，那么将无法获取到 CSRF Token 的值，所以即使发出了请求，服务器也会因为 CSRF Token 不正确而拒绝请求。





### 浏览器网络安全

#### HTTPS

> 使用了 `SSL/TLS`的HTTP

<img src=".\浏览器工作原理-geek\HTTP VS HTTPS.png" style="zoom:50%;" />

因为HTTP是明文传输的，这会带来三大风险：

```
（1） 窃听风险（eavesdropping）：第三方可以获知通信内容。

（2） 篡改风险（tampering）：第三方可以修改通信内容。

（3） 冒充风险（pretending）：第三方可以冒充他人身份参与通信。
```

`SSL/TLS`协议是为了解决这三大风险而设计的，希望达到：

```
（1） 所有信息都是加密传播，第三方无法窃听。

（2） 具有校验机制，一旦被篡改，通信双方会立刻发现。

（3） 配备身份证书，防止身份被冒充。
```

##### SSL/TLS历史

```
1994年，NetScape公司设计了SSL协议（Secure Sockets Layer）的1.0版，但是未发布。

1995年，NetScape公司发布SSL 2.0版，很快发现有严重漏洞。

1996年，SSL 3.0版问世，得到大规模应用。

1999年，互联网标准化组织ISOC接替NetScape公司，发布了SSL的升级版TLS1.0版。

2006年和2008年，TLS进行了两次升级，分别为TLS 1.1版和TLS 1.2版。最新的变动是2011年TLS 1.2的修订版。
```

##### 基本原理

###### 对称加密

> 对称加密是指加密和解密都使用的是相同的密钥

<img src=".\浏览器工作原理-geek\对称加密实现的HTPPS.png" style="zoom:50%;" />

+ 浏览器发送它所支持的加密套件列表和一个随机数 client-random，这里的加密套件是指加密的方法，加密套件列表就是指浏览器能支持多少种加密方法列表。
+ 服务器会从加密套件列表中选取一个加密套件，然后还会生成一个随机数 service-random，并将 service-random 和加密套件列表返回给浏览器。
+ 最后浏览器和服务器分别返回确认消息。

但是其中传输 client-random 和 service-random 的过程却是**明文**的，这意味着**黑客也可以拿到协商的加密套件和双方的随机数，从而合成密钥**。



###### 非对称加密

> 非对称加密算法有 A、B 两把密钥，如果你用 A 密钥来加密，那么只能使用 B 密钥来解密；反过来，如果你要 B 密钥来加密，那么只能用 A 密钥来解密。
>
> 其中把公开出来的密钥称为公钥，自己保留的称为私钥。

<img src=".\浏览器工作原理-geek\非对称加密实现HTTPS.png" style="zoom:50%;" />

+ 首先浏览器还是发送加密套件列表给服务器。
+ 然后服务器会选择一个加密套件，不过和对称加密不同的是，使用非对称加密时服务器上需要有用于浏览器加密的公钥和服务器解密 HTTP 数据的私钥，由于公钥是给浏览器加密使用的，因此服务器会将加密套件和公钥一道发送给浏览器。
+ 最后就是浏览器和服务器返回确认消息。

**两个弊端**：

+ **第一个是非对称加密的效率太低**。这会严重影响到加解密数据的速度，进而影响到用户打开页面的速度。
+ **第二个是无法保证服务器发送给浏览器的数据安全**。虽然浏览器端可以使用公钥来加密，但是服务器端只能采用私钥来加密，私钥加密只有公钥能解密，但黑客也是可以获取得到公钥的，这样就不能保证服务器端数据的安全了。



###### 混合加密

> 在传输数据阶段使用对称加密，但是对称加密的密钥采用非对称加密来传输的加密方式

<img src=".\浏览器工作原理-geek\混合加密实现HTTPS.png" style="zoom:50%;" />

+ 首先浏览器向服务器发送对称加密套件列表、非对称加密套件列表和随机数 client-random；
+ 服务器保存随机数 client-random，选择对称加密和非对称加密的套件，然后生成随机数 service-random，向浏览器发送选择的加密套件、service-random 和公钥；
+ 浏览器保存公钥，并生成随机数 pre-master，然后利用公钥对 pre-master 加密，并向服务器发送加密后的数据；
+ 最后服务器拿出自己的私钥，解密出 pre-master 数据，并返回确认消息。

到此为止，服务器和浏览器就有了共同的 client-random、service-random 和 pre-master，然后服务器和浏览器会使用这三组随机数生成对称密钥，因为服务器和浏览器使用同一套方法来生成密钥，所以最终生成的密钥也是相同的。

**问题：无法确认访问的服务器就是目标服务器**



###### 数字证书

> 由权威机构（Certificate Authority）颁发。有两个作用：
>
> + 向浏览器证明服务器的身份
> + 包含服务器的公钥

**生成**

> 首先 CA 使用 **Hash 函数**来计算申请者提交的明文信息，并得出**信息摘要**；然后 CA 再使用它的**私钥**对信息摘要进行**加密**，加密后的密文就是 CA 颁给申请者的**数字签名**

<img src=".\浏览器工作原理-geek\数字证书的生成.png" style="zoom:50%;" />

**验证**

> 当浏览器向申请者服务器发出请求时，服务器会返回数字证书给浏览器。浏览器接收到数字证书之后，会对数字证书进行验证。
>
> 首先浏览器读取证书中相关的明文信息，采用 CA 签名时相同的 **Hash 函数**来计算并得到**信息摘要 A**；然后再利用对应 CA 的**公钥解密签名数据**，得到**信息摘要 B**；对比信息摘要 A 和信息摘要 B，如果一致，则可以确认证书是合法的，即证明了这个服务器是申请者的；同时浏览器还会验证证书相关的域名信息、有效时间等信息。

<img src=".\浏览器工作原理-geek\数字证书的验证.png" style="zoom:50%;" />



##### 工作流程

<img src=".\浏览器工作原理-geek\完整的HTTPS请求流程.png" style="zoom:50%;" />

相较于混合加密的HTTPS，主要有两点改变：

+ 服务器没有直接返回公钥给浏览器，而是返回了数字证书，而公钥正是包含在数字证书中的；
+ 在浏览器端多了一个证书验证的操作，验证了证书之后，才继续后续流程。

通过引入**数字证书**，我们就实现了**服务器的身份认证功能**，这样即便黑客伪造了服务器，但是由于证书是没有办法伪造的，所以依然无法欺骗用户。



### 浏览器系统安全

> 浏览器在操作系统安全上采取的策略

浏览器被划分为浏览器内核和渲染内核两个核心模块。

<img src=".\浏览器工作原理-geek\操作系统安全角度下的浏览器多进程架构.png" style="zoom:50%;" />

#### 安全沙箱

> 将渲染进程和操作系统隔离的一道墙

##### 产生的缘由

+ 网络资源的内容安全性不可知
+ 恶意程序只会在执行时才会生效

> 基于以上的两个原因，浏览器将**负责执行各种网络资源**的**渲染进程**用安全沙箱进行隔离，限制其对操作系统的操作，进而保护操作系统的安全。



#### 影响

##### 浏览器模块功能的划分

> 因为安全沙箱最小的保护单位是进程，并且能限制进程对操作系统的操作，所有应用了安全沙箱的进程必须没有和操作系统交互的功能。
>
> 由于渲染进程需要安全沙箱的保护，因此需要把在渲染进程内部涉及到和系统交互的功能都转移到浏览器内核中去实现

<img src=".\浏览器工作原理-geek\浏览器内核和渲染进程的各自职责.png" style="zoom:50%;" />

##### 模块功能

###### 持久存储

> 由于安全沙箱需要负责确保渲染进程无法直接访问用户的文件系统，但是在渲染进程内部有访问 Cookie 的需求、有上传文件的需求，为了解决这些文件的访问需求，所以现代浏览器将读写文件的操作全部放在了浏览器内核中实现，然后通过 IPC 将操作结果转发给渲染进程

+ 存储 Cookie 数据的读写。通常浏览器内核会维护一个存放所有 Cookie 的 Cookie 数据库，然后当渲染进程通过 JavaScript 来读取 Cookie 时，渲染进程会通过 IPC 将读取 Cookie 的信息发送给浏览器内核，浏览器内核读取 Cookie 之后再将内容返回给渲染进程。
+ 一些缓存文件的读写也是由浏览器内核实现的，比如网络文件缓存的读取。

###### 网络访问

> 由于安全沙箱的保护，在渲染进程内部是不能直接访问网络的，如果要访问网络，则需要通过浏览器内核。不过浏览器内核在处理 URL 请求之前，会检查渲染进程是否有权限请求该 URL。

###### 用户交互

> 由于安全沙箱的原因，渲染进程无法直接与操作系统通过的UI接口进行交互

浏览器关于用户交互功能的设计，其目的是为了限制渲染进程有监控到用户输入事件的能力

+ 为了向用户显示渲染进程渲染出来的位图，渲染进程需要将生成好的位图发送到浏览器内核，然后浏览器内核将位图复制到屏幕上
+ 操作系统没有将用户输入事件直接传递给渲染进程，而是将这些事件传递给浏览器内核。然后浏览器内核再根据当前浏览器界面的状态来判断如何调度这些事件，如果当前焦点位于浏览器地址栏中，则输入事件会在浏览器内核内部处理；如果当前焦点在页面的区域内，则浏览器内核会将输入事件转发给渲染进程



#### 站点隔离

> 所谓站点隔离（Site Isolation）是指Chrome将同一站点（包含了相同根域名和相同协议）中相互关联的页面放到同一个渲染进程中执行

##### 背景

最初Chrome划分渲染进程是以标签页为单位，也就是说整个标签页会被划分给某个渲染进程。

当一个页面中嵌入多个`iframe`，而这些`iframe`又来自于不同站点时，这就导致了多个不同站点中的内容通过`iframe`同时运行在同一个渲染进程中。

如果说一个页面中包含了一个恶意`iframe`，那么当恶意程序入侵渲染进程后，就可以获取渲染进程中的所有内容了



##### 好处

> 将恶意的 `iframe` 隔离在恶意进程内部，使得它无法继续访问其他 `iframe` 进程的内容，因此也就无法攻击其他站点了

