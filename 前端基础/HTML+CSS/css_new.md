## 概述

> 层叠样式表（**C**ascading **S**tyle **S**heet，简称：CSS），它是一门样式表语言，可以用它来选择性地为网页中的 HTML 元素添加样式。它描述的是HTML元素的布局和表现。

### 诞生背景

​		在20世纪90年代，网站的主要功能就是信息展示，在那个年代，在互联网领域中，信息就是图片和文字。CSS 的诞生就是为图文信息展示服务的。

### 发展历程

+ 1996年12月17日CSS1诞生
+ 1998年5月12日CSS2发布
+ 2007年CSS2.1发布

### 基本机制

​		CSS 采用了一种称为“文档流”的定位和布局机制来处理图文信息的展示，该机制也是 CSS 基本的定位和布局机制，HTML 默认使用“文档流”进行元素的排列和定位。

### CSS3

​		随着时代的变迁和科技的发展（用户设备升级），人们对互联网的需求也在变化（用户的产品需求提高），以前的以图文展示为主的门户网站已经无法满足用户的需求，为了实现更丰富、更复杂的网页，CSS3应运而生。

​		CSS 的规范是基于当前环境制定的，如果 CSS 的规范从制定到最终浏览器完全支持需要很长时间，可能会出现新特性还未支持就已经过时的情况。因此，为了加速没有争议的 CSS 特性的标准化，W3C 的 CSS 工作组做了一项被称为“Beijing doctrine”的决定，该决定将 CSS 划分为更小的组件，并把这些组件称为模块。这些模块互相独立，各自按照自己的速度走向标准化。也就说，CSS3 这个词实际上名存实亡，CSS 标准从此由大版本时代进入模块化时代。

## 语法

### 语句

> css样式表由一系列的语句组成。css中有两种语句：at-rule和ruleset

#### at-rule

一个 **at-rule** 是一个CSS 语句，以at符号开头, '`@`' (`U+0040 COMMERCIAL AT`), 后跟一个标识符，并包括直到下一个分号的所有内容, '`;`' (`U+003B SEMICOLON`), 或下一个CSS块，以先到者为准。

下面是一些 @规则, 由它们的标识符指定, 每种规则都有不同的语法:

- [`@charset`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/@charset), 定义样式表使用的字符集。
- [`@import`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/@import), 告诉 CSS 引擎引入一个外部样式表。
- [`@namespace`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/@namespace), 告诉 CSS 引擎必须考虑XML命名空间。
- 嵌套@规则, 是嵌套语句的子集,不仅可以作为样式表里的一个语句，也可以用在条件规则组里：
  - [`@media`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/@media), 如果满足**媒介查询的条件**则条件规则组里的规则生效。
  - [`@page`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/@page), 描述打印文档时布局的变化。
  - [`@font-face`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/@font-face), 描述将下载的外部的字体。
  - [`@keyframes`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/@keyframes), 描述 CSS 动画的关键帧。
  - [`@supports`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/@supports), 如果满足**给定条件**则条件规则组里的规则生效。
  - [`@document`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/@document), 如果文档样式表满足给定条件则条件规则组里的规则生效。 *(推延至 CSS Level 4 规范)*

#### ruleset

<img src="D:\Notes\前端基础\HTML+CSS\css图\css-ruleset-structure.png" style="zoom:50%;" />

整个结构称为 **规则集**（通常简称“规则”），由选择器和声明块构成，各部分释义如下：

- 选择器（**Selector**）

  HTML 元素的名称位于规则集开始。它选择了一个或多个需要添加样式的元素（在这个例子中就是 `p` 元素）。要给不同元素添加样式只需要更改选择器就行了。

- 声明块（**Declaration block**）

  由一对大括号`{}`及包含在内的0个或多个声明组成。

+ 声明（**Declaration**）

  一个单独的规则，如 `color: red;` 用来指定添加样式元素的**属性**。

+ 属性（**Properties**）

  改变 HTML 元素样式的途径。（本例中 `color` 就是 `p`元素的属性。）CSS 中，由编写人员决定修改哪个属性以改变规则。

+ 属性的值（**Property value**）

  在属性的右边，冒号后面即**属性的值**，它从指定属性的众多可选值中选择一个值（除了 `red` 之外还有很多属性值可以用于 `color` ）。

注意其他重要的语法：

- 每个规则集（除了选择器的部分）都应该包含在成对的大括号里（`{}`），大括号及里面的一系列声明构成一个声明块。
- 在每个声明里要用冒号（`:`）将属性与属性值分隔开。
- 在每个规则集里要用分号（`;`）将各个声明分隔开。

### 选择器

> 在CSS中，模式匹配规则确定样式规则适用于文档树中的哪些元素。 这些模式称为选择器，从简单的元素名称模式到丰富的上下文模式。 如果模式中的所有条件对于某个元素都为真，则选择器匹配该元素。

**选择器使用原则**

+ 根据 id 选单个元素
+ class 和 class 的组合选成组元素
+ tag 选择器确定页面风格

**选择器类型**

+ 简单选择器

  > **元素上的单个条件**

  + 类型
  + 通用
  + 属性
  + 类
  + ID
  + 伪类
    + 树结构关系伪类
    + 链接与行为伪类
    + 逻辑伪类
    + 其他伪类

+ 复合选择器

  > 复合选择器是一系列没有被组合器分隔的简单的选择器，代表**单个元素上的一组同时条件**。

+ 复杂选择器

  > 复杂选择器是由组合器分隔的一个或多个复合选择器的序列。 它代表由其组合器描述的**特定关系**的**一组元素**上的**一组同时条件**。

  组合器

  + 后代组合器（空格）
  + 子代组合器（>）
  + 相邻兄弟组合器（+）
  + 后继兄弟组合器（~）

+ 选择器列表

  > 由逗号分隔的简单、复合、复杂选择器列表，逗号表示“或”的关系。

**选择器优先级**

> 当一个元素被多个规则命中，不同规则指定同一属性为不同值时，就需要考虑优先级的问题。

### CSS属性值

任何 CSS 属性一定包含一个或多个数据类型。

#### 数据类型

CSS 数据类型定义了一个 CSS 属性值集合。在规范的语法格式中，数据类型使用关键字外加一定尖括号（`<`和`>`）表示。例如数值类型是<number>，色值类型是<color>等。

#### 属性值定义语法

CSS 属性值有专门的定义语法，用来表示 CSS 属性值的合法组成。该语法包含以下3种基本组成元素：

+ 关键字；
+ 数据类型；
+ 符合。

例如线性渐变的语法：linear-gradient([<angle> | to  <side or corner> ,]? <color-stop-list>)。其中：

+ `to` 是关键字;
+ <angle>、<side or corner> 和 <color-stop-list>是数据类型；
+ `[]`、`?`、`,`是符合。

##### 1.关键字

关键字通常分为通用关键字和全局关键字：

+ auto、none、ease等关键字是通用关键字，或者可以称为普通关键字，这些关键字均只被部分 CSS 属性支持；
+ inherit、initial、unset 和 revert 是全局关键字，属于被所有 CSS 属性支持的特殊关键字。

##### 2.数据类型

解释见上文。

##### 3.符号

CSS 语法中的符合分为字面符号、组合符号和数量符号这3类。

（1）字面符号指的是 CSS 属性值中原本就支持的合法符号，这些符号在 CSS 语法中会按照其原本的字面意义呈现。

| 符号 | 名称       | 描述                                                         |
| ---- | ---------- | ------------------------------------------------------------ |
| ，   | 并列分隔符 | 用来分割数个并列值，或者分割函数的参数值                     |
| /    | 缩写分隔符 | 用来分割一个值的多个部分，在 CSS 缩写中用于分离类型相同但属于不同 CSS 属性的值，以及用在部分 CSS 函数中 |

（2）组合符号用来表示数个基本元素之间的组合关系。表中从上到下组合符号的优先级越来越高。

| 符号 | 名称         | 描述                                                         |
| ---- | ------------ | ------------------------------------------------------------ |
|      | 并列         | 符号为普通空格字符，表示各部分必须出现，同时需要按顺序出现   |
| &&   | “与”组合符   | 各部分必须出现，但可以不按顺序出现                           |
| \|\| | “或”组合符   | 各部分至少出现一个，可以不按顺序出现                         |
| \|   | “互斥”组合符 | 各部分恰好出现其中一个                                       |
| []   | 方括号       | 将各部分进行分组以绕过上面几个符号的优先规则，因此方括号的优先级最高 |

（3）数量符号用来描述一个元素可以出现多少次，数量符号不能叠加出现，并且优先级高于组合符号。

| 符号   | 名称       | 描述                                                         |
| ------ | ---------- | ------------------------------------------------------------ |
|        | 无数量符号 | 恰好出现一次                                                 |
| *      | 星号       | 可以出现任意次数                                             |
| +      | 加号       | 可以出现一次或多次                                           |
| ？     | 问号       | 可以出现零次或者一次，也就是该元素可有可无                   |
| {A，B} | 花括号     | 出现最少A次，最多B次                                         |
| #      | 井号       | 可以出现一次或多次，但多次出现时必须以逗号分隔               |
| ！     | 叹号       | 表示出现分组必须产生一个值，该符合多出现在组合符号方括号的后面 |

#### 全局关键字属性值

在 CSS 中有四个全局关键字属性值，分别是 inherit、initial、unset、revert。

+ inherit

  强制当前 CSS 属性的计算值使用父元素属性的计算值。

+ initial

  强制当前 CSS 属性的计算值还原成 CSS 语法中规定的初始值。

+ unset

  如果属性具有继承特性，则按 inherit 处理；如果不是则按 initial 处理。

+ revert

  强制当前 CSS 属性的计算值还原成浏览器内置的值。



CSS 单位

+ 长度单位

  + 相对长度

    + 相对于字体

      rem、em、ex、cap、ch、ic、lh、rlh

    + 相对于视口

      vw、vh、vi、vb、vmax、vmin

  + 绝对长度

    mm、Q、in、pt、pc、px

+ 角度单位

  deg、grad、rad、turn

+ 时间单位

  s、ms

+ 频率单位

  Hz、kHz

+ 分辨率单位

  dpi、dpcm、dppx

### CSS属性赋值规则

> 浏览器在解析文档并构建文档树之后，它必须为树中的每个元素的每个样式属性分配一个适用于目标媒体类型的值。
>
> 属性的最终值是一个六步计算的结果：
>
> 1、首先，收集所有应用到元素上的声明值（declared values）。每个元素的每个属性可能有0个或多个声明值
>
> 2、根据级联规则对元素属性的所有声明值进行优先级排序，优先级最高的即为元素属性的级联值（cascaded value）。每个元素的每个属性最多只有一个级联值
>
> 3、如果元素属性产生了级联值，则该值为指定值（specified value）；如果没有级联值，则使用属性的默认值（defaulted）作为指定值
>
> 4、将指定值解析为用于继承的值（computed value）
>
> 5、如果必要的话，将computed value转换为绝对值（used value使用值）
>
> 6、根据本地环境的限制进行转换（actual value）

+ specified values

  得出specified value的机制：

  + **如果级联产生了一个值，则使用该值**。此外，如果该值为‘inherit’，则：

    每个属性还可以具有“ inherit”的级联值，这意味着对于给定元素，该属性将元素父级的计算值作为指定值。 “inherit”值可用于强制值的继承，也可用于通常不继承的属性。如果在根元素上设置了“继承”值，则会为属性分配其初始值。

  + 否则，如果该属性是继承的，并且该元素不是root元素，则使用父元素的computed value。

  + 否则，（该属性既没有cascade value，也不是继承来的）使用属性的初始值（initial value）。每个属性的初始值在属性的定义中指定。

+ computed values

  在级联过程中，将指定值(specified values)解析为计算值； 例如，将URI设置为绝对，然后将“ em”和“ ex”单位计算为像素或绝对长度。

+ used values

  使用值（used value）是采用计算值（computed value）并将任何剩余依赖项解析为绝对值的结果。

+ actual values

  使用值（used value）原则上是用于渲染的值，但是user agent可能无法在给定环境中使用该值，这时需要根据具体环境进行转换。

#### 默认

当级联过程没有产生值时，则需要通过其他规则来确定指定值

+ 如果元素的属性为继承属性，则属性值默认为父元素属性的计算值（对于根元素，继承值为属性的初始值）
+ 如果元素的属性既不是继承的，也没有产生级联值，则属性值默认为初始值（initial value）

**显式默认**

可以通过给元素属性显式赋值的形式，请求元素属性采用默认值

如果一个属性的级联值为initial、inherit、unset关键字，则：

+ inherit

  强制元素继承父元素的计算值

+ initial

  强制元素属性值采用初始值

+ unset

  如果属性为继承属性，则按inherit处理；如果不是则按initial处理

#### 继承

“继承”是CSS中另一个重要概念。在W3C规范中，描述每个CSS属性时都会有一个选项是“Inherited”，如果值为“no”表示该属性是不可继承的。



### 级联变量

级联变量作为一个新的原始值类型，能够在所有 CSS 属性中使用，自定义属性用于定义它们。使用级联变量可以解决数据值的复用和维护问题。

#### 定义自定义属性

自定义属性和普通属性一样，可以在任何元素上声明，按照正常的继承和级联规则来解析，可以使用@media 和其他条件规则进行条件化，可以在 HTML 的 style 属性中使用，可以通过 CSSOM 进行读取或设置等。

```
--<自定义属性名>: <自定义属性值> 
```

#### 使用级联变量

`var()` 函数可以通过引用自定义属性的值来作为另一个属性的值。 var() 的语法为：

```
var( <自定义属性名> , <默认值>? ) // 只有当自定义属性没有定义时，默认值才会生效
```

`var()` 函数可用于替代元素上任何属性的值的任何部分。 但 `var()` 函数不能用作属性名称、选择器或除属性值之外的任何其他内容。 

##### 变量解析

`var()` 总是从当前元素所关联的自定义属性中查询自定义属性，并获取其计算值。

##### 无效的变量

当使用变量定义一个属性的值时，如果变量解析生成的属性值不合法：

+ 如果该属性可继承，则属性值为继承值；
+ 如果该属性不可继承，则属性值为 `initial` 值。

表现的和属性值为 `unset` 时一样。



## 元素与基本尺寸

### 元素

> 按照元素在水平流方向上是否独占一行，可将元素分为两类：
>
> + 块级元素
> + 内联级元素

在 CSS 中，每个元素都对应着两个盒子：

+ 外在盒子：负责元素是否独占一行等布局行为，有 inline 和 block 两种。
+ 内在盒子（容器盒子）：负责元素的宽高、内容呈现等

元素的显示分为两种类型：

+ 外部显示：影响外部元素布局和定位
+ 内部显示：决定内部元素布局和定位

元素的尺寸分为两种类型：

+ 外部尺寸：元素的尺寸由外部元素决定
+ 内部尺寸：元素的尺寸由内部元素决定



### 尺寸

> width/height 默认作用于元素的容器盒子（内在盒子）的 content box 结构

#### width: auto

width 的默认值为 auto，它至少包含了以下三种不同的宽度表现：

+ 充分利用可用空间。块级元素的宽度默认为其“包含块”容器宽度的 100%。
+ 包裹性。浮动元素、绝对定位元素、inline-block 元素和 table 元素的宽度“收缩到合适”。
+ 超出容器限制。元素宽度不会主动超过其“包含块”容器宽度，除非出现一些特殊情况，如：出现内容很长的连续英文和数字，或者内联元素被设置了 white-space：nowrap。

##### 外部尺寸与流体特性

width: auto 的外部尺寸表现形式：

+ 正常流宽度

  块级元素的宽度默认会占满整个“包含块”容器宽度，就像水流一样。这就是容器盒子的流特性，这是一种 margin/border/padding 和content 内容区域自动分配水平空间的机制。

+ 格式化宽度

  格式化宽度仅仅出现在绝对定位模型中，和正常流一样具有完全的流动性。在默认情况下，绝对定位元素的宽度表现是“包裹性”，宽度由内部尺寸决定，但当 left/right 或 top/bottom 对立方位的属性值同时存在的时候，元素的宽度表现为“格式化宽度”，其宽度大小相对于最近的具有定位特性的祖先元素计算。

##### 内部尺寸与流体特性

所谓“内部尺寸”，即元素的尺寸由内部的元素决定，而非外部的容器决定，表现为当该元素里面没有内容时，宽度为0，表明应用的是“内部尺寸”。在 CSS 中，“内部尺寸”有下面三种表现形式：

+ 包裹性

  也叫“自适应性”，指元素尺寸由内部元素决定，但永远小于“包含块”容器的尺寸（除非容器尺寸小于元素的“首选最小宽度”）

+ 首选最小宽度

  首选最小宽度指的是元素最合适的最小宽度，具体表现规则如下：

  + 汉字的最小宽度为每个汉字的宽度
  + 西方文字最小宽度由特定的连续的英文字符单元决定
  + 类似图片这样的替换元素的最小宽度就是元素内容自身的宽度

+ 最大宽度

  最大宽度就是元素可以有的最大宽度。最大宽度实际等同于“包裹性”元素设置 white-space：nowrap 声明后的宽度。



#### height

##### auto

+ 内部尺寸

  元素整体高度为内部元素高度的叠加值

+ 外部尺寸

  同 width 的格式化宽度

##### 100%

当父元素的 `height：auto` 时，子元素不支持 `height：100%`，原因如下：

当元素的包含块的高度没有指定（即高度由内容决定），并且该元素不是绝对定位，则计算值为 auto，即 `’auto‘ * 100/100 = NaN`



#### box-sizing

> 用于改变元素 width/height 作用的对象

其属性值可为“容器盒子”的三个组成部分：

+ content-box：默认值
+ padding-box：部分浏览器支持
+ border-box

##### 发明初衷

为了实现表单等替换元素能够整体自适应其“包含块”容器。因为替换元素的尺寸由内部元素决定，且表单元素需要设置 border 和一定的 padding 大小，这样使得 width/border 和 padding 注定要共存，同时还要整体宽度自适应容器，如果不借助外部标签，将无法实现。box-sizing 的发明可以完美解决替换元素宽度自适应问题。



## 盒模型

> CSS 盒模型描述了为文档树中的元素生成的矩形盒，该矩形盒根据格式化上下文进行布局。

每个盒子都有一个内容区域和可选的围绕内容区域的填充、边框和边距区域；每个区域的大小都有对应的属性指定，每个区域的周长称为边，每个边可以划分为四部分：top、right、bottom、left。

 <img src=".\css图\box-model.png" style="zoom:80%;" />

- **Content edge**：内容区域边缘围绕着由元素的 height 和 width 属性给定的矩形。
- **Padding edge**：填充区域边缘围绕着填充盒子。如果填充区域的宽度为0，则填充边缘与内容边缘相同。
- **Border edge**：边框区域边缘围绕边框盒子。如果边框区域的宽度为0，则边框边缘与填充边缘相同。
- **Margin edge**：边距区域边缘围绕边距盒子。如果边距区域的宽度为0，则边距边缘和边框边缘相同。



## 层叠

### 样式层叠

> 样式表可能有三个不同的来源：author、user、user agent。
>
> 这三个来源的样式表在作用域上会重叠，并且会根据级联进行交互。
>
> CSS级联为每个样式规则分配权重。 当应用多个规则时，权重最大的规则优先。
>
> 默认情况下，**作者样式表中的规则比用户样式表中的规则具有更大的权重。 但是，对于“! important”规则，优先级相反。 与UA的默认样式表中的规则相比，所有用户和作者规则的权重都更大。**

+ cascading order

  要查找元素/属性组合的值，用户代理必须应用以下排序顺序

  + 1.查找适用于目标媒体类型的所有相关元素和属性的声明。 如果关联的选择器与所讨论的元素匹配，并且目标媒体与包含声明的所有@media规则以及到达样式表的路径上的所有链接上的媒体列表相匹配，则声明适用。
  + 2.根据**重要性**（normal or important）和**来源**（author、user、user agent）。按升序排列为：
    1. user agent declarations
    2. **user normal declarations**
    3. author normal declarations
    4. author important declarations
    5. **user important declarations**
  + 3.按**选择器的特异性对具有相同重要性和来源的规则进行排序**：更具体的选择器将覆盖更通用的选择器。 伪元素和伪类分别计为普通元素和类。
  + 4.最后，按指定的顺序排序：如果两个声明的**重要性，来源和特异性相同**，则以**后者为准**。导入的样式表中的声明被视为在样式表本身中的任何声明之前。

+ !important rules

  !important 声明的规则优先级高于普通声明，并且user中的‘!important’优先级高于author。

+ calculating a selector's specificity

  A selector's specificity is calculated as follows:

  - count 1 if the declaration is from is a 'style' attribute rather than a rule with a selector, 0 otherwise (= a) (In HTML, values of an element's "style" attribute are style sheet rules. These rules have no selectors, so a=1, b=0, c=0, and d=0.)
  - count the number of **ID** attributes in the selector (= b)
  - count the number of **other attributes and class and pseudo-classes** in the selector (= c)
  - count the number of **element names and pseudo-elements** in the selector (= d)

### 元素层叠（stacking）

#### 层叠上下文（context）

​	平时我们从设备终端看到的HTML文档都是一个平面的，事实上HTML文档中的元素却是存在于三个维度中。

<img src="D:\Notes\前端基础\HTML+CSS\css图\document-model.png" style="zoom:50%;" />

​	该系统包括一个三维`z` 轴，其中的元素是层叠（Stacked）的。`z` 轴的方向指向查看者，`x` 轴指向屏幕的右边，`y` 轴指向屏幕的底部。

<img src="D:\Notes\前端基础\HTML+CSS\css图\stacking-context.png" style="zoom:50%;" />

​	事实上，每个HTML元素都属于一个层叠上下文。给定层叠上下文中的每个定位元素都具有一个整数的层叠层级，具有更大堆栈级别的元素盒子总是在具有较低堆栈级别的盒子的前面（上面）。

​	文档中的层叠上下文由满足以下任意一个条件的元素形成：

- 根元素 (`<html>`)
- `z-index` 值不为`auto` 的
- `position` 值为非`static` 
- 一个`z-index` 值不为`auto` 的 Flex 项目 (Flex item)，即：父元素`display: flex|inline-flex` 
- `opacity` 属性值小于`1` 的元素
- `transform` 属性值不为`none` 的元素
- `mix-blend-mode` 属性值不为`normal` 的元素
- `filter` 、`perspective` 、`clip-path` 、`mask` 、`motion-path` 值不为`none` 的元素
- `perspective` 值不为`none` 的元素
- `isolation` 属性被设置为`isolate` 的元素
- 在`will-change` 中指定了任意 CSS 属性，即便你没有直接指定这些属性的值

​	每个页面都有一个默认的层叠上下文，这个层叠上下文的根就是html元素。html元素中的一切都被置于这个默认的层叠上下文的一个层叠层上。

#### 层叠水平（level）

​	层叠水平（Stacking Level）决定了**同一个层叠上下文**中元素在**`z`轴**上的**显示顺序**。所有的元素都有层叠水平，包括层叠上下文元素（**层叠上下文元素可能是另一层叠上下文中的普通元素**）。普通元素的层叠水平优先由层叠上下文决定，因此，层叠水平的比较只有在当前层叠上下文元素中才有意义。

​	注意，层叠水平和css的`z-index`属性不是同一个概念，`z-index`可以影响层叠水平，但只限于定位元素以及Flex盒子的孩子元素。

#### 层叠顺序（order）

在HTML文档中，默认情况之下有一个自然层叠顺序（Natural Stacing Order），即元素在`z` 轴上的顺序。它是由许多因素决定的。比如下面这个列表，它显示了元素盒子放入层叠顺序上下文的顺序，从层叠的底部开始，共有七种层叠等级：

- 背景和边框：形成层叠上下文的元素的背景和边框。层叠上下文中的最低等级。
- 负`z-index` 值：层叠上下文内有着负`z-index` 值的子元素。
- 块级盒：文档流中非行内非定位子元素。
- 浮动盒：非定位浮动元素。
- 行内盒：文档流中行内级别非定位子元素。
- `z-index: 0` ：定位元素。这些元素形成了新的层叠上下文。
- 正`z-index` 值：定位元素。层叠上下文中的最高等级。

<img src="D:\Notes\前端基础\HTML+CSS\css图\stacking-order.png" style="zoom:50%;" />



## 定位与布局

### 包含块

元素 box 的尺寸或位置有时需要根据某个矩形来计算，这个矩形被称为该元素的‘包含块’。（采用百分比来定义元素 box 的 width、height、padding、margin，**绝对定位元素的offset属性**等）

**初始包含块**

> 以整个 `canvas` (渲染内容的区域) 的坐标原点(左上)为基准，以 `viewport` (显示渲染内容的区域)为大小的矩形。

**“包含块”的定义**

+ 对于根元素来说，其包含块是一个被称为‘**初始包含块**’的矩形，对于连续媒体，**它具备和视口一样的尺寸，并被固定在画布原点**；对于分页媒体，**它为页面区域**。

+ 对于其他元素

  + position 属性值为 relative 或 static

    则包含块由作为**块容器**或**建立格式化上下文**的父元素的‘**content edge**’（盒子模型的内容框）形成。

  + position 属性值为 fixed

    在连续媒体里，包含块为**视口**；在分页媒体里，包含块为页面区域。

  + position 属性值为 absolute

    + 有 position 属性值不为 static 的祖先元素

    ​       **祖先元素为 inline 元素：**

    ​		其他情况：包含块为祖先元素的‘**padding edge**’形成。

    + 没有 position 属性值不为 static 的祖先元素

      包含块为**初始包含块**

### 盒子生成

> 盒子具有不同的类型，盒子的类型部分地影响其在格式化上下文中的行为。 display 属性指定了元素生成的盒子的类型。

display 属性的某些值会使元素生成包含后代盒子和生成内容的主盒子。除了主盒子之外，一些元素可能会生成附加的盒子：'list-item' 元素。这些附加盒子相对于主盒子放置。

+ 块级元素和块级盒子（`block-level`）

  > 块级元素是指生成块级主盒子（在视觉上格式化为块，参与块格式化上下文）的元素。
  >
  > 使元素成为块级的 display 属性值包括：block、list-item、table。

  + 块容器元素和块容器盒子（`block container`）

    > 主盒子是块容器盒子的元素是块容器元素。
    >
    > 使非替换元素生成块容器盒子的 display 属性值包括：block、list-item、inline-block
    >
    > 一个块容器盒子，当包含**内联级盒子**时，就会建立一个内联格式化上下文，用于**格式化内联级盒子**。

    + 块级盒子一般也是块容器盒子，除非它是表格盒子或可替换元素生成的主盒
    + 块容器盒子不一定是块级盒子：非替换的内联级块盒子、非替换的表单元格（table cell）

  + 块盒（`block box`）

    > 块级的块容器盒子称为块盒

  + 匿名块盒子

+ 内联级元素和内联级盒子（`inline-level`）

  > 内联级元素是指生成内联级盒子（参与内联格式化上下文）的元素。它们不构成新的内容块，按行分布。
  >
  > 使元素成为内联级的 display 属性值包括：inline、inline-table、inline-block。

  + 内联盒子（`inline box`）

    > 内联盒子既是**内联级别**的，并且其内容参与**其包含的内联格式化上下文**。
    >
    > display 值为 inline 的非替换元素会生成一个内联盒子。

  + 原子内联级盒子（`atomic inline-level boxes`）

    > 不是内联盒子的**内联级**盒子（如可替换的内联级元素、内联块元素和内联表元素）被称为**原子内联级盒子**，因为它们作为**单个不透明盒子参与其内联格式上下文**。

  + 匿名内联盒子（`anonymous inline boxes`）

    > 任何直接包含在块容器元素内（而不是内联元素内）的文本都必须被视为匿名内联元素，其生成的盒子即为匿名内联盒子。
    >
    > 这种匿名内联盒子从它们的块父盒子继承可继承的属性。非继承属性的值为初始值。



### 格式化上下文

CSS 格式化上下文 ，也被称作视觉格式化模型 ，**指页面中一个渲染区域，拥有一套渲染规则，用来控制盒子的布局**。

**其主要作用是决定盒子模型的布局，其子元素将如何定位以及和其他元素的关系和相互作用**



### 定位方案

在 CSS 中，元素盒子的位置由其所采用的定位方案所对应的定位算法计算得出。在 CSS2.2 中，有三种定位方案：

1. 普通文档流。普通文档流包括块级盒子的块格式化，内联级盒子的内联格式化以及块级和内联级盒子的相对定位。
2. 浮动。在浮动模型中，盒子首先根据普通文档流来定位，然后脱离流并尽可能的向左或向右移动。
3. 绝对定位。在绝对定位模型中，盒子被完全地从流中移除并相对一个包含块计算得出位置。

#### 普通文档流

> CSS 中的一种最基本的定位和布局机制，HTML 默认采用该布局，其包含三个部分：BFC、IFC、position：relative。

##### BFC

> 是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。BFC实际上就是页面中一块渲染区域，该区域与其他区域隔离开来。容器里面子元素不会影响到外部，外部的元素也不会影响到容器里的子元素。

BFC 内部的盒子会从上至下一个接着一个顺序排列，同一 BFC 内的相邻块级盒子之间的垂直边距折叠。每个元素的左侧最外层边界与包含块 BFC 的左边相接触(对于从左往右的格式化，右边接触)。即使存在浮动也是如此。BFC 的区域不会与浮动元素的盒子折叠。**BFC 的高度也会受到浮动元素的影响，浮动元素参与计算**。

`html`元素默认使用块格式上下文，这意味着`<html>`元素块中的每个元素都是按照正常流程遵循块和内联布局规则进行布局的。默认为块布局的任何元素也会为其后代元素创建块格式上下文。此外，还有一些CSS属性可以使元素创建一个BFC，即使默认情况下它不这样做。

下面这些规则可以创建一个BFC：

- 浮动元素（元素的`float` 不是`none` ）
- 绝对定位元素（元素的`position` 为`absolute` 或`fixed` ）
- 行内块元素（元素的`display` 为`inline-block` ）
- 表格单元格（元素的`display` 为`table-cell` ，HTML表格单元格默认为该值）
- 表格标题（元素的`display` 为`table-caption` ，HTML表格标题默认为该值）
- 匿名表格单元格元素（元素的`display` 为`table` 、`table-row` 、`table-row-group` 、`table-header-group` 、`table-footer-group` （分别是HTML`table` 、`row` 、`tbody` 、`thead` 、`tfoot` 的默认属性）或`inline-table` ）
- `overflow` 值不为`visible` 的块元素
- `display` 值为`flow-root` 的元素
- `contain` 值为`layout` 、`content` 或`strict` 的元素
- 弹性元素（`display` 为`flex` 或`inline-flex` 元素的直接子元素）
- 网格元素（`display` 为`grid` 或`inline-grid` 元素的直接子元素）
- 多列容器（元素的`column-count` 或`column-width` 不为`auto` ，包括`column-count` 为`1` ）
- `column-span` 为`all` 的元素始终会创建一个新的BFC，即使该元素没有包裹在一个多列容器中

块格式化上下文包含创建它的元素内部的所有内容。其主要使用：

- 创建独立的渲染环境
- 防止因浮动导致的高度塌陷
- 防止上下相邻的外边距折叠

##### IFC

> 内联格式化上下文由包含非块级盒子的块容器盒子建立（当块容器盒子里有内联级盒子时）。

- 在内联格式化上下文中，内联级盒子从包含块的顶部开始一个接一个地水平排列，受水平方向的margin、border和padding影响
- 在内联格式化上下文中，内联级盒子可以以不同的方式在垂直方向上对齐：盒子底部或顶部，盒子内的文本的基线等等。
- 包含由一个个内联级盒子组成的行的矩形框称为**行框盒子（line box）**。当多个内联级盒子无法水平放置在单个行框盒子中时，它们会分布在两个或多个垂直堆叠的行框盒子中。
- 通常，行框盒子的左边缘接触其包含块的左边缘，而右边缘接触其包含块的右边缘，但浮动盒子可能位于包含块边缘和行框盒子边缘之间，因此，尽管同一内联格式化上下文中的行框盒子通常具有相同的宽度（包含块的宽度），但如果由于浮动盒子而减少了可用的水平空间，它们的宽度可能会有所不同，所以，**行框盒子的宽度**由**包含块的宽度**和**浮动盒子的存在**共同决定。同一内联格式上下文中的行框盒子通常高度不同，每个行框盒子的高度一般由其包含的**高度最高**的那个内联级盒子**决定**，对于仅包含**非替换元素盒子**的行框，其高度**本质上完全**由`line-height`属性决定（但如果各内联盒子中文本的字体字号不同，最终高度会受`vertical-align`属性的影响）。
- 当一个内联级盒子的宽度小于包含它的行框盒子的宽度时，它们在行框中的水平分布由`text-align`属性决定。内联级盒子在行框内垂直方向上的定位由`vertical-align`属性决定。
- 当一个内联级盒子超过一个行框盒子的宽度时，它会被拆分成几个内联级盒子，这些盒子分布在几个行框上，如果内联级盒子无法拆分，则内联级盒子溢出行框。

##### 相对定位

盒子的位置是按照正常流计算的（这叫做正常流中的位置）。 然后盒子相对于它的正常位置偏移。



#### 浮动

> 产生浮动的盒子会向左或向右移动，直到其外边缘接触到**包含块盒子的边缘**或另一个浮动盒子的外边缘。如果没有足够的水平空间放置浮动盒子，则将其向下移动，直到空间合适。内容会沿着浮动盒子的一侧向下流动（左浮动盒子的右侧和右浮动盒子的左侧）。

+ 脱离文档流。在浮动盒子之前和之后创建的非定位块级盒子垂直流动，就好像浮动盒子不存在一样。但是，在浮动盒子旁边的行框盒子会根据需要缩短，以便为浮动盒子在水平方向上腾出空间。
+ 如果缩短的行框盒子太小而无法包含任何内容，则行框盒子向下移动（并重新计算其宽度），直到某些内容适合或不再存在浮动盒子。

**clear**

> 此属性指示元素盒子的哪一侧可能不与较早的浮动框相邻。 'clear' 属性不考虑元素本身或其他块格式上下文中的浮动。

当应用于非浮动块级盒子时，值具有以下含义：

+ left

  要求盒子的顶部边框边缘低于由源文档中较早的元素产生的任何左浮动盒子的底部外边缘。

+ right

  要求盒子的顶部边框边缘低于由源文档中较早的元素产生的任何右浮动盒子的底部外边缘。

+ both

  要求盒子的顶部边框边缘低于由源文档中较早的元素产生的任何右浮动和左浮动盒子的底部外边缘。



#### 绝对定位

> 如果一个元素的‘position’属性的值为‘static’外任何值，那么这个元素被称为‘be positioned’，即被定位了。

+ **盒子偏移**

> 被定位的元素box，其left、top、right、bottom的大小表示的是
>
> + position为absolute或fixed
>
>   其**包含块**的边框与其**‘margin edge’**之间的距离。
>
> + position为relative
>
>   与其自身原来位置之间的距离。

开启绝对定位的元素，将会脱离普通文档流，处于更高的层级（普通文档流中的元素会占据其在普通文档流中的位置），**如果没有设置top、left、right、bottom属性值**，则默认为auto，而不是left：0；top：0；时的位置，**默认覆盖在其普通文档流中的位置的上方。**



### display，position，float之间的关系

这三个属性共同影响着盒子的生成和布局，它们之间的交互关系如下：

+ 如果display的值为none

  position和float将不会起作用。在这种情况下，元素不会生成盒子。

+ 当display的值不为none时

  + 如果position的值为absolute或fixed，那么这个盒子就被绝对定位了，此时，float的值会被计算为none，display的值将根据下表设置。盒子的位置将由top、right、bottom和left以及盒子的包含块决定。
  + 如果float的值不是none，那么盒子将被浮动，display的值将根据下表设置。
  + 如果元素为根元素，则根据下表设置display的值。在 CSS 2.2 中未定义 list-item 的指定值是否对应 block 或 list-item 的计算值。
  + 其他情况下，display的值为对应指定值。

  | Specified value                                              | Computed value    |
  | ------------------------------------------------------------ | ----------------- |
  | inline-table                                                 | table             |
  | inline, table-row-group, table-column, table-column-group, table-header-group, table-footer-group, table-row, table-cell, table-caption, inline-block | block             |
  | others                                                       | same as specified |



### 布局

#### 弹性布局

> 当`display` 取值为`flex` 或`inline-flex` ，将会创建一个Flexbox容器。**该容器为其内容创建一个新的格式化上下文，即Flex格式化上下文。**

不过要注意的是，Flexbox容器不是块容器（块级盒子），下列适用于块布局的属性并不适用于Flexbox布局：

- 多列中的`column-*` 属性不适用于Flexbox容器
- `float` 和`clear` 属性作用于Flex项目上将无效，也不会把Flex项目脱离文档流
- `vertical-algin` 属性作用于Flex项目上将无效
- `::first-line` 和`::first-letter` 伪元素不适用于Flexbox容器，而且Flexbox容器不为他们的祖先提供第一个格式化的行或第一个字母

![](.\css图\flexbox.png)

##### Flex布局是什么

Flex布局：Flex是Flexible box的缩写，意为“弹性布局”，是W3C在2009年提出的一种新的网页布局方案，它可以根据屏幕的大小以及设备的类型来使网页元素更好的进行排列、对齐和分配空白空间。

任何一个容器都可以指定为 Flex 布局。 

块元素声明方式

````css
.box{
    display: flex
}
````

行内元素声明方式

````css
.box{
    display： inline-flex
}
````

注意：当设为Flex布局后，其子元素的float、clear和vertical-align属性将失效。

采用Flex布局的元素，称为Flex容器，它的所有子元素自动成为容器成员，称为Flex项目。

容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做`main start`，结束位置叫做`main end`；交叉轴的开始位置叫做`cross start`，结束位置叫做`cross end`。

项目默认沿主轴排列。单个项目占据的主轴空间叫做`main size`，占据的交叉轴空间叫做`cross size`。

##### 容器属性

- flex-direction  属性决定主轴的方向（即项目的排列方向） ，它有四个值。

  - `row`（默认值）：主轴为水平方向，起点在左端。
  - `row-reverse`：主轴为水平方向，起点在右端。
  - `column`：主轴为垂直方向，起点在上沿。
  - `column-reverse`：主轴为垂直方向，起点在下沿。

- flex-wrap 属性定义，如果一条轴线排不下，如何换行。  它可能取三个值。 

  +  `nowrap`（默认）：不换行。 
  +  `wrap`：换行，第一行在上方。 
  +  `wrap-reverse`：换行，第一行在下方。 

- flex-flow 属性是`flex-direction`属性和`flex-wrap`属性的简写形式，默认值为`row nowrap`。 

- justify-content 属性定义了项目在主轴上的对齐方式。  它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。 

  - `flex-start`（默认值）：左对齐
  - `flex-end`：右对齐
  - `center`： 居中
  - `space-between`：两端对齐，项目之间的间隔都相等。
  - `space-around`：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。

- align-items 属性定义项目在交叉轴上如何对齐。  它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。

  - `flex-start`：交叉轴的起点对齐。
  - `flex-end`：交叉轴的终点对齐。
  - `center`：交叉轴的中点对齐。
  - `baseline`: 项目的第一行文字的基线对齐。
  - `stretch`（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。

- align-content 属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。  该属性可能取6个值。 

  - `flex-start`：与交叉轴的起点对齐。
  - `flex-end`：与交叉轴的终点对齐。
  - `center`：与交叉轴的中点对齐。
  - `space-between`：与交叉轴两端对齐，轴线之间的间隔平均分布。
  - `space-around`：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。
  - `stretch`（默认值）：轴线占满整个交叉轴。

##### 项目属性

 以下6个属性设置在项目上。 

- `order` 属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。 

- `flex-grow`属性定义项目的放大比例，默认为`0`，即如果存在剩余空间，也不放大。

  如果所有项目的`flex-grow`属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的`flex-grow`属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 

- `flex-shrink`属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。

  如果所有项目的`flex-shrink`属性都为1，当空间不足时，都将等比例缩小。如果一个项目的`flex-shrink`属性为0，其他项目都为1，则空间不足时，前者不缩小。

  负值对该属性无效。

- `flex-basis` 属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为`auto`，即项目的本来大小。 

- `flex` 属性是`flex-grow`, `flex-shrink` 和 `flex-basis`的简写，默认值为`0 1 auto`。后两个属性可选。 

  该属性有两个快捷值：`auto` (`1 1 auto`) 和 none (`0 0 auto`)。 

- `align-self` 属性允许单个项目有与其他项目不一样的对齐方式，可覆盖`align-items`属性。默认值为`auto`，表示继承父元素的`align-items`属性，如果没有父元素，则等同于`stretch`。 



#### 网格布局

> 元素的`display` 值为`grid` 或`inline-grid` 时，将会创建一个Grid容器。**该容器为其内容创建一个新的格式化上下文，即Grid格式化上下文。**

网格容器不是块容器，因此一些假定为块布局设计的属性并不适用于网格格式化上下文中。特别是：

- `float` 和`clear` 运用于网格项目将不会生效。但是`float` 属性仍然影响网格完完全全器子元素上`display` 的计算值，因为这发生在确定网格项目之前
- `vertical-align` 运用于网格项目也将不会生效
- `::first-line` 和`::first-letter` 伪元素不适用于网格容器，而且网格容器不向它们社先提供第一个格式化行或第一个格式化字母

#### 分栏布局



## 视觉表现

### 变换

2D变换和3D变换

### 过渡

### 动画

### 滤镜

### 混合模式

### 遮罩

### 剪裁

### 用户行为